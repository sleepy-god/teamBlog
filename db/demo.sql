/*
 Navicat Premium Data Transfer

 Source Server         : localhost_27017
 Source Server Type    : MongoDB
 Source Server Version : 40209
 Source Host           : localhost:27017
 Source Schema         : demo

 Target Server Type    : MongoDB
 Target Server Version : 40209
 File Encoding         : 65001

 Date: 29/09/2020 11:06:42
*/


// ----------------------------
// Collection structure for apps
// ----------------------------
db.getCollection("apps").drop();
db.createCollection("apps");

// ----------------------------
// Documents of apps
// ----------------------------
db.getCollection("apps").insert([ {
    _id: ObjectId("5eef25a02cc62301246012b9"),
    count: [
        NumberInt("0"),
        NumberInt("30"),
        NumberInt("6"),
        NumberInt("0")
    ],
    date: [
        "06-21",
        "06-22",
        "06-23",
        "06-24"
    ],
    username: "星雪工作室",
    __v: NumberInt("0")
} ]);
db.getCollection("apps").insert([ {
    _id: ObjectId("5eef284a68e4b7415c23e101"),
    count: [
        NumberInt("72"),
        NumberInt("60"),
        NumberInt("4"),
        NumberInt("24"),
        NumberInt("0")
    ],
    date: [
        "06-22",
        "06-23",
        "06-24",
        "06-27",
        "07-15"
    ],
    username: "幻尘",
    __v: NumberInt("0")
} ]);

// ----------------------------
// Collection structure for articles
// ----------------------------
db.getCollection("articles").drop();
db.createCollection("articles");

// ----------------------------
// Documents of articles
// ----------------------------
db.getCollection("articles").insert([ {
    _id: ObjectId("5ef1b52c65a6e22e78429e03"),
    tags: [
        "前端",
        "面试",
        "腾讯"
    ],
    author: "幻尘",
    id: NumberInt("0"),
    article: "---\ntitle: 腾讯Web前端开发暑期实习生\n\ndate: 2020.03.11\ntop_img:\ncover: https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2072221314,1084284933&fm=26&gp=0.jpg\n\n---\n\n##  第一次面试\n\n3号下午六点突然接到了一个电话，显示微应用的号码，电话里，腾讯的面试官告诉我晚上7点进行电话面试\n\n心情瞬间开始变得兴奋和紧张\n\n紧张的是没有什么准备很突然，兴奋是因为这是第一次专业的面试\n\n虽然总体表现不是很好，但是通过这次面试也给自己找到了很多不足的地方，面试之后总结了题目，发出来共勉一下\n\n\n> __1、面试开始是简单的自我介绍__\n>\n> 我说了自己的学习历程，说了些参与过的小项目，然后就进入了正式的面试环节\n\n***\n\n###  JS\n\n***\n\n> __2、JavaScript的数据类型有哪些？__\n>\n> 基本数据类型：String 、 Number 、 Boolean 、 null 、 undefined\n>\n> 引用数据类型：Function 、 Object 、 Array\n>\n> ***\n>\n> __3、undefined与null的区别（想起来一大部分有一些是面试后补充的）__\n>\n> undefined表示\"缺失值\",null表示没有对象，\n>\n> undefined与null值相同但是类型不相同\n>\n> 声明变量后不赋值就会默认为undefined，函数无返回值时也会默认undefined，调用函数时没有提供相对应的参数，参数也会默认undefined\n>\n> null可以用作函数的参数，表示该函数的参数不是对象，也可以作为原型链的终点\n>\n> ***\n>\n> __4、在日常应用中，undefined和null的常用方式__\n>\n> undefined用于清空变量，null用于清空对象\n>\n> ***\n>\n> __5、JSON的格式是什么__\n>\n> {'':'','':''}\n>\n> ***\n>\n> __6、JS中JSON相关的内置对象__\n>\n> Json.stringify() 将js对象或数组转换为字符串\n>\n> JSON.parse() 将文本解析为js对象\n\n***\n\n>***\n>\n>自我感觉上面答的还可以，主要也是由于那几天在重新温习js和学习es6，脑子里面全是js相关的东西，然而从这后面的就开始了I Don't Know的旅程\n\n***\n\n###  H5\n\n***\n\n>__7、H5有哪些新特性(这个还是知道的)__\n>\n>audio、video、canvas、article、footer、section、nav、header、表单控件email、date、time、url、search、地理定位、缓存application cach\n>\n>***\n>\n>__8、简单说一下H5的语义化（说实话一瞬间就懵了，这之前真没听过语义化）__\n>\n>后续搜索的答案：\n>\n>将标签优化使页面结构更加清晰，增加可读性，有利于SEO优化；根据文档上下文选择合适的语义化标签<nav\\><header\\><section\\><footer\\>等；尽量减少使用无语义化的标签如<div\\><span\\>；添加title和kewords；不使用带有样式的标签，用css设置样式\n\n***\n\n###  浏览器相关\n\n>__9、从用户输入url到页面显示都发生了什么__\n>\n>(1)客户端通过DNS解析获得服务器的ip\n>\n>(2)三次握手建立tcp链接\n>\n>(3)浏览器向服务器发送HTTP请求\n>\n>(4)服务器回应HTTP响应\n>\n>(5)浏览器接收HTTP响应的数据\n>\n>(6)浏览器解析html文件，根据标签生成DOM树\n>\n>(7)浏览器解析css，生成CSSOM树\n>\n>(8)浏览器将DOM树和CSSOM树合并，构建渲染树\n>\n>(9)浏览器进行布局、绘制、重绘和回流\n>\n>(10)浏览器与服务器四次挥手断开链接\n>\n>***\n>\n>__10、具体描述一下浏览器的重绘与回流__\n>\n>重绘：根据元素的新属性重新绘制，使元素呈现新的外观\n>\n>回流：当render tree中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建称为回流\n>\n>区别：回流一定会引起重绘，而重绘不一定引起回流\n>\n>***\n>\n>__11、浏览器的缓存类型__\n>\n>协商缓存：每次读取缓存时，先到服务器去验证是否有改变，如果有就获取，没有就从缓存中读取，响应code为304\n>\n>强制缓存：只要缓存没过有效期，就强制读取缓存，响应code为200，该类缓存必定要持久化到disk\n>\n>***\n>\n>__12、浏览器的常用缓存机制__\n>\n>http缓存：基于http协议的浏览器文件缓存机制，当重复请求某一个文件时，浏览器可以根据协议的头文件判断是从服务端请求文件还是从本地读取文件\n>\n>cookies：用于标识用户的一小块数据信息，可在浏览器与服务器之间传递\n>\n>localStorage：要访问同一个localStorage页面必须同源，没有时间限制的数据存储，主要可用于存储ajax请求返回的数据\n>\n>sessionStorage：只能被最初存储对象的页面所访问，针对一个session的数据存储，浏览器关闭后就会删除\n\n***\n\n###  数据结构\n\n>！！！不问我真的没意识到这些知识已经忘光了，欲哭无泪啊！！！\n>\n>***\n>\n>__13、二叉树的遍历方式有哪些？__\n>\n>前序遍历，中序遍历，后序遍历和层序遍历\n>\n>***\n>\n>__14、二叉树如何删除一个节点？__\n>\n>先确定树的类型，然后找到节点的位置，如果节点是最底层的子节点，就直接置空；如果有一个左子节点或右子节点，则将子节点拼接在要删除的节点的父节点上；如果有左子节点和右子节点，则依序寻找未删除的下一个遍历位置，在不改变原有顺序的情况向将节点进行置换，改变树的结构\n\n***\n\n###  操作系统\n\n>__15、简单说一下线程与进程__\n>\n>进程是并发执行的程序在执行过程中分配和管理资源的基本单位，是竞争计算机系统资源的基本单位\n>\n>线程是进程的一个执行单元，是进程内可调度的一个实体\n>\n>一个程序至少有一个进程，一个进程至少有一个线程\n>\n>区别:\n>\n>&emsp;&emsp;_地址空间_：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。\n>\n>&emsp;&emsp;_资源拥有_：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。\n>\n>&emsp;&emsp;_开销_：线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行；进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移。\n\n***\n\n###  计算机网络\n\n>__16、HTTP的状态码及其描述__\n>\n>2**处理成功\n>\n>3**重定向\n>\n>4**客户端错误\n>\n>5**服务器错误\n>\n>| 状态码 | 作用                                                         |\n>| ------ | ------------------------------------------------------------ |\n>| 200    | 请求成功，服务器成功处理了请求                               |\n>| 201    | 请求成功，并且服务器新创建了资源                             |\n>| 202    | 请求成功但服务器尚未处理                                     |\n>| 301    | 永久重定向，页面永久跳转到新的url                            |\n>| 302    | 临时重定向，服务器目前从不同位置的网页响应请求，但请求仍继续使用原有位置来进行以后的请求 |\n>| 403    | 服务器已接收请求，但拒绝处理                                 |\n>| 404    | 页面url未找到                                                |\n>| 500    | 服务器错误                                                   |\n>| 502    | 网关错误                                                     |\n>| 503    | 由于超载或正在维护，服务器暂时不可用                         |\n\n***\n\n以上就是这次面试的全部题目了，总结一下这次面试：\n\n全程很紧张，没有什么准备太突然了，暴露了很多缺点，大多数内容只是会用，却没记住，对基础内容掌握还不透彻，对算法，操作系统等大多数之前掌握的知识现在都忘了，也体现了记笔记和记博客的重要性，虽然这次面试很有挫败感，但是也给了我接下来学习的方向和动力，相信努力总是会有回报的！",
    title: "腾讯Web前端开发暑期实习生(提前批)",
    date: "2020.3.11",
    cate: "面试经验",
    type: "personal",
    brief: "3号下午六点突然接到了一个电话，显示微应用的号码，电话里，腾讯的面试官告诉我晚上7点进行电话面试\n心情瞬间开始变得兴奋和紧张\n紧张的是没有什么准备很突然，兴奋是因为这是第一次专业的面试\n虽然总体表现不是很好，但是通过这次面试也给自己找到了很多不足的地方，面试之后总结了题目，发出来共勉一下\n> __1、面试开始是简单的自我介绍__\n>\n> 我说了自己的学习历程，说了些参与过的小项目，然后就进入了正式的面试环节\n***\n###  JS\n***\n> __2、JavaScript的数据类型有哪些？__\n>\n> 基本数据类型：String 、 Number 、 Boolean 、 null 、 undefined\n>\n> 引用数据类型：Function 、 Object 、 Array\n>\n> ***\n>\n> __3、undefined与null的区别（想起来一大部分有一些是面试后补充的）__\n>\n> undefined表示\"缺失值\",null表示没有对象，\n>\n> undefined与null值相同但是类型不相同\n>\n> 声明变量后不赋值就会默认为undefined，函数无返回值时也会默认undefined，调用函数时没有提供相对应的参数，参数也会默认undefined\n>\n> null可以用作函数的参数，表示该函数的参数不是对象，也可以作为原型链的终点\n>\n> ***\n>\n> __4、在日常应用中，undefined和null的常用方式__\n>\n> undefined用于清空变量，null用于清空对象\n>",
    imgUrl: "https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2072221314,1084284933&fm=26&gp=0.jpg",
    __v: NumberInt("0")
} ]);
db.getCollection("articles").insert([ {
    _id: ObjectId("5ef1ba2c9b875a35a8961177"),
    tags: [
        "前端",
        "面试",
        "腾讯"
    ],
    author: "幻尘",
    id: NumberInt("1"),
    article: "---\ntitle: 腾讯前端实习生（视频面试）\ndate: 2020-03-14 11:00:17\n\ntop_img:\ncover: https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2072221314,1084284933&fm=26&gp=0.jpg\n\n---\n\n修改简历之后本以为无望，结果9号突然收到了腾讯的面试邀请函，经过询问了解到，腾讯的简历机制是一个部门对你进行面试时会锁定你的简历，然后如果面试没通过就会放开简历，投入简历库，等其他部门来捞\n\n废话少说，直接进入正题，下面列举我记下的面试时被问到的问题及之后查到的正确答案\n\n***\n\n>##  计算机网络\n>\n>###  简述一下OSI参考模型\n>\n>物理层，数据链路层，网络层，传输层，会话层，表示层，应用层\n>\n>***\n>\n>###  http与https各自时属于哪一层的协议\n>\n>http是应用层协议，https因为进过ssl加密所以是网络层协议\n>\n>***\n>\n>###  了解状态码吗,403、502各自代表什么\n>\n>2xx是请求成功，3xx是重定向，4xx是客户端错误，5xx是服务器错误\n>\n>403是服务器接收请求但是拒绝处理，502是网关错误\n\n***\n\n>##  JS相关\n>\n>###  什么情况会引发内存泄漏\n>\n>当时回答了闭包，下面是后来查到的：\n>\n>1. 意外的局部变量\n>\n>2. 被遗忘的计时器或回调函数\n>\n>3. 闭包\n>\n>4. 脱离DOM的引用\n>\n>***\n>\n>###  什么是跨域问题，跨域问题源于什么策略，怎么解决跨域问题\n>\n>跨域问题是当协议，域名，端口其中任意一个不相同时引起的无法访问\n>\n>跨域是由于浏览器的同源策略而产生的\n>\n>解决方法：\n>\n>1.JSONP(动态创建script标签和回调函数，模拟get请求)\n>\n>2.CORS response加header(\"Access-control-Allow-origin:x\"),header(\"Access-control-Allow-Method:post/Get\")\n>\n>3.nginx转发（使用反向代理，向中间服务器发送请求，中间服务器请求到数据后返回给客户端）\n>\n>4.HttpClient(请求转发)\n\n***\n\n>## 编码题\n>\n>最让我受刺激的两道题，心态炸裂，也不知道怎么回事，刚看完的都能忘，还是太菜了\n>\n>###  手写一个isArray()判断是不是数组\n\n```javascript\nfunction isArray(arr) {\n    //1、推荐方式\n    return Object.prototype.toString.call(arr) === \"[object Array]\"\n    //2、instanceof判断\n\t//千万不能用typeof 返回的是object\n     return arr instanceof Array;\n    //3、官方方法\n    return Array.isArray(arr);\n}\n\n```\n\n>>***\n>>\n>>###  写一个能生成min到max之间随机数的函数**\n>\n>>```javascript\n>>function myRandom(min, max) {\n>>return Math.floor(Math.random() * max + min);\n>>}\n>>```\n>\n>***\n>\n>面试时间很短就半小时，可能是看我着两个代码写的太差劲了，我自己当时都自闭了，问了我一些项目问题，问了学校的实习政策，问了最近学习中遇到的困难，之后就结束了，这次面试时间不长，虽然表现比上一次突然袭击好的多但是还是不尽人意，还不够完美，基础还是不扎实依旧需要磨练，面试结束我也清楚没有二面了，心情的确有点失落，但是还好还有努力空间，还有我自己的学习方向，加油，继续努力！\n>\n>\n>![](/image/yqh.png)",
    title: "腾讯Web前端开发暑期实习生(视频一面)",
    date: "2020.3.14",
    cate: "面试经验",
    type: "personal",
    brief: "修改简历之后本以为无望，结果9号突然收到了腾讯的面试邀请函，经过询问了解到，腾讯的简历机制是一个部门对你进行面试时会锁定你的简历，然后如果面试没通过就会放开简历，投入简历库，等其他部门来捞\n废话少说，直接进入正题，下面列举我记下的面试时被问到的问题及之后查到的正确答案\n***\n>##  计算机网络\n>\n>###  简述一下OSI参考模型\n>\n>物理层，数据链路层，网络层，传输层，会话层，表示层，应用层\n>\n>***\n>\n>###  http与https各自时属于哪一层的协议\n>\n>http是应用层协议，https因为进过ssl加密所以是网络层协议\n>\n>***\n>\n>###  了解状态码吗,403、502各自代表什么\n>\n>2xx是请求成功，3xx是重定向，4xx是客户端错误，5xx是服务器错误\n>\n>403是服务器接收请求但是拒绝处理，502是网关错误\n***\n>##  JS相关\n>\n>###  什么情况会引发内存泄漏\n>\n>当时回答了闭包，下面是后来查到的：\n>\n>1. 意外的局部变量\n>\n>2. 被遗忘的计时器或回调函数\n>\n>3. 闭包\n>\n>4. 脱离DOM的引用\n>\n>***\n>\n>###  什么是跨域问题，跨域问题源于什么策略，怎么解决跨域问题\n>\n>跨域问题是当协议，域名，端口其中任意一个不相同时引起的无法访问\n>",
    imgUrl: "https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2072221314,1084284933&fm=26&gp=0.jpg",
    __v: NumberInt("0")
} ]);
db.getCollection("articles").insert([ {
    _id: ObjectId("5ef1bac19b875a35a8961178"),
    tags: [
        "前端",
        "面试",
        "美团"
    ],
    author: "幻尘",
    id: NumberInt("2"),
    article: "---\ntitle: 美团前端实习面试\ndate: 2020-03-21 17:29:44\ntags:\ntop-img:\ncover: https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1880610474,661989955&fm=26&gp=0.jpg\n\n---\n\n面试开始比较戏剧性，我在调整设备时发现聊天室显示对方已经进入房间，我就点了接受面试邀请，面试官小哥哥也还没准备好，商量了一下，面试就这样开始了\n\n面试官问我我先手写两个代码可以吗，当然同意了！\n\n***\n\n>##  数据结构\n>\n>###  二叉树的中序遍历\n\n```javascript\nclass Node{\n    constructor(value){\n        this.value = value,\n        this.left = this.right = null\n    }\n}\n\nclass BiTree{\n    constructor(){\n        this.root = null\n    }\n}\n```\n\n```javascript\n//递归写法\nlet Order = (root) =>{\n    if(!root) return [];\n    let arr = [];\n    let traversal = (root) =>{\n        if(root.left) traversal(root.left);\n        arr.push(root.value);\n        if(root.right) traversal(root.right);\n    }\n\n    return arr;\n}\n```\n\n```javascript\n//非递归写法\nlet Order = (root) => {\n    if (!root) return [];\n    let arr = [],\n        stack = [];\n    let p = root;\n    while (stack.length || p) {\n        while (p) {\n            stack.push(p);\n            p = p.left;\n        }\n        let node = stack.pop();\n        arr.push(node.value);\n        p = node.right;\n    }\n\n    return arr;\n}\n```\n\n***\n\n>##  JS\n>\n>###  ES6的特性有哪些\n>\n>回答了let，const，块级作用域，promise，class\n>\n>当然不止上述，还有proxy，解构赋值，set，map，箭头函数，Symbol，Module\n>\n>***\n>\n>###  解释一下什么是class，class与function体哦那有什么区别\n>\n>我的答案是：class实质上是function的一种变形，class是es6对对象的快速定义写法，本质上还是属于function，是一种特殊的function\n>\n>面试结束后找到的《ECMAScript 6 入门》（阮一峰）里面的原话：ES6的class可以看作是一个语法糖，class知识让对象原型的写法更加清晰，更向面向对象编程的语法而已\n\n***\n\n随后面试官问我用什么其他准备的还阔以的科目，我说计网吧，但是没想到的是我无意间给自己连挖了好几个坑！\n\n***\n\n>##  计算机网络\n>\n>###  说一下OSI参考模型\n>\n>物理层，数据链路层，网络层，传输层，会话层，表示层，应用层\n>\n>***\n>\n>### 简单说一下每一层的作用\n>\n>这个问题一问我就开始有点慌，但还是稍微答了几个\n>\n>物理层：定义物理设备的标准，主要对物理连接方式等指定同一标准 协议：IEEE 802.1，IEEE 802.2等\n>\n>数据链路层：对物理层传输的比特流包装，检测保证数据传输的可靠性，可以进行物理寻址\n>\n>网络层：控制子网的运行，提供点到点的服务，提供网络重各个主机之间的数据通信 协议：IP/HTTP/ICMP/IGMP/ARP/RAPP\n>\n>传输层：定义一些传输数据的协议和端口，可用于建立虚拟链接 协议：TCP/UDP\n>\n>会话层：可使应用建立和维持会话，并能使会话获得同步\n>\n>表示层：为异种机通信提供一种公共语言\n>\n>应用层：是网络向用户提供服务的最终窗口，可支持用户联网的应用的要求 协议：FTP/SMTP/DNS/HTTP\n>\n>***\n>\n>### TCP和UDP各属于哪一层，有什么区别\n>\n>他们都属于传输层协议\n>\n>UDP协议全称是用户数据报协议，是一种无连接的协议。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的\n>\n>TCP是可靠的面向连接的网络协议，只能进行一对一通信，tcp的连接建立需要三次握手，连接拆除需要四次挥手\n>\n>***\n>\n>### （第二道代码题）用A,B代表主机模拟Tcp三次握手\n\n```javascript\n//SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送)  FIN(finish结束) RST(reset重置)  URG(urgent紧急)  SEQ(Sequence number顺序号码) ack(Acknowledge number确认号码)\n\nA -> B: SYN = 1, SEQ = x\n\nB -> A: SYN = 1, ACK = 1, ack = x + 1, SEQ = y\n\nA -> B: ACK = 1, seq = x + 1, ack = y + 1 \n```\n\n>***\n>\n>**HTTP和HTTPs各属于哪一层**\n>\n>HTTP属于应用层，https用于使用SSL加密属于网络层\n>\n>***\n>\n>###  HTTP常见的报头有哪些？\n>\n>一个都没想起来，下面答案也不全是我后来查到的常用的\n>\n>Accept: 能正确接收的媒体类型\n>\n>Accept-Encoding: 能正确接受的编码格式列表\n>\n>Cookie: 发给服务器的Cookie信息\n>\n>Host: 服务器域名\n>\n>User-Agent: 客户端信息\n>\n>server: 服务器名字\n>\n>set-cookie: 需要存在客户端的信息，用于识别用户身份\n>\n>***\n>\n>###  简述一下DNS请求过程\n>\n>DNS请求时由浏览器发起的，浏览器先查询自身内存中是否解析过这个域名，如果没有，则向本地服务器发起DNS请求，本地服务器查询到服务器地址即返回服务器地址，如果没有，则本地服务器向根服务器发送请求，根服务器会返回一个所查询域的主域名服务器地址，本地服务器随即向此域名服务器发送请求，域名服务器如果没有查询到，则重复上一步骤，直到查到为止，如果查到了，则查询后返回该域名对应的ip地址，本队服务器将对应ip与域名存储在缓存中，然后将结果返回给用户，用户将地址存在缓存中，DNS解析至此结束\n\n***\n\n>##  操作系统\n>\n>###  什么时进程？什么时线程？\n>\n>进程是一个计算机程序运行的过程，进程是计算机资源分配的基本单位，线程是进程中执行运算的一个最小单位，一个进程至少要有一个线程\n>\n>***\n>\n>###  进程与进程，线程与线程之间的通信方式有哪些？\n>\n>一瞬间想到的是socket通信，随后面试官补充了共享内存（即利用文件进行通信）\n>\n>正确答案：管道（pipe），信号(signal)，消息队列（message queue），共享内存（shared memory），信号量(semaphore)，套接字（socket）\n>\n>***\n>\n>###  线程中常见的锁\n>\n>公平锁与非公平锁，递归锁，独占锁，共享锁\n>\n>***\n>\n>###  简述一下什么是死锁，怎么会形成死锁，死锁的解决方法（完全忘记）\n>\n>如果一个进程集合里面的每个进程都在等待这个集合中的其他一个进程（包括自身）才能继续往下执行，若无外力他们将无法推进，这种情况就是死锁，处于死锁状态的进程称为死锁进程。\n>\n>*产生原因：*\n>1.因竞争资源发生死锁现象：系统中供多个进程共享的资源的数目不足以满足全部进程的需要时，就会引起对诸资源的竞争而发生死锁现象；\n>\n>2.进程推进顺序不当发生死锁\n>\n>形成死锁的四个必要条件：互斥条件，请求和保持条件，不可剥夺条件，环路等待条件\n>\n>两个进程同时抢占两个资源，进程1抢到a没抢到b，进程2抢到b没抢到a就会发生死锁\n>\n>*处理死锁的基本方法*\n>\n>1、预防死锁：通过设置一些限制条件，去破坏产生死锁的必要条件\n>\n>2、避免死锁：在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁\n>\n>3.检测死锁：允许死锁的发生，但是通过系统的检测之后，采取一些措施，将死锁清除掉\n>\n>4.解除死锁：该方法与检测死锁配合使用\n\n***\n\n这次面试问题和前两次差不多，这些问题其实大部分都准备过，但是一到面试就忘了，面试官很亲切给我提了很多意见，我虚心采纳，面试官相当nice，就像面试官说的基础知识看似没用，其实是大问题的变形我还需要更多的积累与磨练，这样才能展现更好的自己！！！",
    title: "美团前端实习面试",
    date: "2020.3.21",
    cate: "面试经验",
    type: "personal",
    brief: "面试开始比较戏剧性，我在调整设备时发现聊天室显示对方已经进入房间，我就点了接受面试邀请，面试官小哥哥也还没准备好，商量了一下，面试就这样开始了\n面试官问我我先手写两个代码可以吗，当然同意了！\n***\n>##  数据结构\n>\n>###  二叉树的中序遍历\n```javascript\nclass Node{\n    constructor(value){\n        this.value = value,\n        this.left = this.right = null\n    }\n}\nclass BiTree{\n    constructor(){\n        this.root = null\n    }\n}\n```\n```javascript\n//递归写法\nlet Order = (root) =>{\n    if(!root) return [];\n    let arr = [];\n    let traversal = (root) =>{\n        if(root.left) traversal(root.left);\n        arr.push(root.value);\n        if(root.right) traversal(root.right);\n    }\n    return arr;\n}\n```\n```javascript\n//非递归写法\nlet Order = (root) => {\n    if (!root) return [];\n    let arr = [],\n        stack = [];\n    let p = root;\n    while (stack.length || p) {\n        while (p) {\n            stack.push(p);\n            p = p.left;\n        }\n        let node = stack.pop();\n        arr.push(node.value);\n        p = node.right;\n    }\n    return arr;\n}\n```\n***\n>##  JS\n>\n>###  ES6的特性有哪些\n>\n>回答了let，const，块级作用域，promise，class\n>\n>当然不止上述，还有proxy，解构赋值，set，map，箭头函数，Symbol，Module\n>\n>***\n>\n>###  解释一下什么是class，class与function体哦那有什么区别\n>\n>我的答案是：class实质上是function的一种变形，class是es6对对象的快速定义写法，本质上还是属于function，是一种特殊的function\n>\n>面试结束后找到的《ECMAScript 6 入门》（阮一峰）里面的原话：ES6的class可以看作是一个语法糖，class知识让对象原型的写法更加清晰，更向面向对象编程的语法而已\n***\n随后面试官问我用什么其他准备的还阔以的科目，我说计网吧，但是没想到的是我无意间给自己连挖了好几个坑！\n***\n>##  计算机网络\n>\n>###  说一下OSI参考模型\n>\n>物理层，数据链路层，网络层，传输层，会话层，表示层，应用层\n>\n>***\n>\n>### 简单说一下每一层的作用\n>\n>这个问题一问我就开始有点慌，但还是稍微答了几个\n>\n>物理层：定义物理设备的标准，主要对物理连接方式等指定同一标准 协议：IEEE 802.1，IEEE 802.2等\n>\n>数据链路层：对物理层传输的比特流包装，检测保证数据传输的可靠性，可以进行物理寻址\n>\n>网络层：控制子网的运行，提供点到点的服务，提供网络重各个主机之间的数据通信 协议：IP/HTTP/ICMP/IGMP/ARP/RAPP\n>\n>传输层：定义一些传输数据的协议和端口，可用于建立虚拟链接 协议：TCP/UDP\n>\n>会话层：可使应用建立和维持会话，并能使会话获得同步\n>",
    imgUrl: "https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1880610474,661989955&fm=26&gp=0.jpg",
    __v: NumberInt("0")
} ]);
db.getCollection("articles").insert([ {
    _id: ObjectId("5eef245c7408064f34fa324e"),
    author: "幻尘",
    id: NumberInt("3"),
    title: "HTTP1.x与Http2.0简单介绍与分析",
    date: "2020.5.28",
    cate: "技术研究",
    tags: [
        "协议",
        "网络",
        "前端",
        "HTTP"
    ],
    type: "personal",
    imgUrl: "https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=853068356,698173734&fm=26&gp=0.jpg",
    brief: "一、什么是HTTP协议\n\n* HTTP协议，全称超文本传输协议，属于网络结构OSI参考模型的“最上层”应用层，由请求与响应构成，是无状态的协议。\n\n* HTTP占用默认端口号为80，可承载在TLS和SSL之上，通过加密、认证的方式实现数据传输，即HTTPS协议，默认端口443  \n\n### 二、HTTP1.0，HTTP1.1，HTTP2.0的特性与区别\n\n* HTTP1.1使用长连接，有效减少三次握手的开销\n* HTTP1.1允许只发送header信息不携带body，此时如果服务器认为客户端拥有权限，就会向客户端发送100，客户端接收100hou再向服务器发送 body信息\n* HTTP1.0没有host域HTTTP1.1才开始支持\n* HTTP1.x的致命缺陷：\n  * 协议规定客户端对同一域的并发连接只能由一个，而一个 页面至少需要加载40个资源\n  * 线头阻塞（Head of line blocking）同一个连接中...",
    article: "---\ntop-img:\ncover: https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=853068356,698173734&fm=26&gp=0.jpg\n\n---\n\n***\n\n# HTTP协议和HTTP1.0/1.1/2.0的区别\n\n###  一、什么是HTTP协议\n\n* HTTP协议，全称超文本传输协议，属于网络结构OSI参考模型的“最上层”应用层，由请求与响应构成，是无状态的协议。\n\n* HTTP占用默认端口号为80，可承载在TLS和SSL之上，通过加密、认证的方式实现数据传输，即HTTPS协议，默认端口443  \n\n### 二、HTTP1.0，HTTP1.1，HTTP2.0的特性与区别\n\n* HTTP1.1使用长连接，有效减少三次握手的开销\n* HTTP1.1允许只发送header信息不携带body，此时如果服务器认为客户端拥有权限，就会向客户端发送100，客户端接收100hou再向服务器发送 body信息\n* HTTP1.0没有host域HTTTP1.1才开始支持\n* HTTP1.x的致命缺陷：\n  * 协议规定客户端对同一域的并发连接只能由一个，而一个 页面至少需要加载40个资源\n  * 线头阻塞（Head of line blocking）同一个连接中的请求，需要一个一个的收发，效率太低\n  * 基于文本协议，请求与响应头信息非常大，无法进行压缩\n  * 只能单向请求，即服务端只能返回客户端的指定请求\n* HTTP2.0的特点：使用了多路复用、HOPACK头压缩、流+二进制帧，流优先级等技术\n* HTTP2.0使用了多路复用技术，允许同时通过单一的HTTP/2连接发起请求-响应信息，是解决HTTP1.x<font color=\"red\">并发问题</font>和<font color=\"red\">HOLB线头问题</font>的核心技术\n* ![alt 图片](https://images2018.cnblogs.com/blog/951506/201803/951506-20180330005255437-1566386281.jpg)\n* HTTP2在原有HTTP基础上在应用层（HTTP2）和传输层（TCP/UDP）之间增加了<font color=\"red\">二进制分帧层</font>\n* HTTP2允许客户端发送请求后，服务端将所有相关文件一并返回，并加入浏览器缓存，减少请求次数\n* HTTP2带来的好处：\n  * 更小的传输体积，更小甚至省略的头消息\n  * 突破原有的TCP连接并发限制，使用一个TCP可实现多请求并发，减少了服务端的压力\n  * 解决 HOLB 线头问题，慢的请求或者先发送的请求不会阻塞其他请求的返回\n  * 结合CDN提供实时性更高，不会出现先发送的请求阻塞后面的请求\n  * 数据优先级可控\n  * 能在不中断TCP连接的情况下停止数据的发送\n\n\n\n",
    __v: NumberInt("0")
} ]);
db.getCollection("articles").insert([ {
    _id: ObjectId("5eef24bd66663b4d0c95ada4"),
    author: "幻尘",
    id: NumberInt("4"),
    title: "JavaScript -- this的使用",
    date: "2020.5.29",
    cate: "Js学习",
    tags: [
        "Js",
        "前端"
    ],
    type: "personal",
    imgUrl: "https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3095136509,3220724763&fm=26&gp=0.jpg",
    brief: "通过阅读MDN和各类博客复习了一下javascript中this的使用方法\n\n\n\n##  什么是this\n\n在传统的面向对象语言中this关键字指代了当前对象本身，或者是当前对象的一个实例，通过使用this可以对其中方法与属性进行调用\n\n在javascript中<font color=\"red\">this</font>的指向是临时决定的，而不是在创建时决定的，大多数情况下函数的调用方式决定了this的指向\n\n***\n\n##  全局环境中的this  \n\n无论是否处于严格模式下，在全局环境中this都唯一指向全局对象window（浏览器下）\n\n```javascript\nconsole.log(this === window); //true\n\t\nvar a = 3;\nconsole.log(a); //3\nconsole.log(this.a) //3\n```\n\n[^1]: 在任何情况下都可以直接使用globalThis获取全局对象，无论是否在当前上下文中运行\n\n***\n\n##  函数环境下的this\n\n###  直接调用 ...",
    article: "---\ntop-img:\ncover: https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3095136509,3220724763&fm=26&gp=0.jpg\n\n---\n\n#  JavaScript -- this的使用\n\n***\n\n通过阅读MDN和各类博客复习了一下javascript中this的使用方法\n\n\n\n##  什么是this\n\n在传统的面向对象语言中this关键字指代了当前对象本身，或者是当前对象的一个实例，通过使用this可以对其中方法与属性进行调用\n\n在javascript中<font color=\"red\">this</font>的指向是临时决定的，而不是在创建时决定的，大多数情况下函数的调用方式决定了this的指向\n\n***\n\n##  全局环境中的this  \n\n无论是否处于严格模式下，在全局环境中this都唯一指向全局对象window（浏览器下）\n\n```javascript\nconsole.log(this === window); //true\n\t\nvar a = 3;\nconsole.log(a); //3\nconsole.log(this.a) //3\n```\n\n[^1]: 在任何情况下都可以直接使用globalThis获取全局对象，无论是否在当前上下文中运行\n\n***\n\n##  函数环境下的this\n\n###  直接调用 \n\n* 在非严格模式下直接调用函数，则函数中的this指向全局\n* 在严格模式下调用函数，则此函数中的this会被赋值为undefined\n* 非严格模式\n\n```js\nfunction foo() {\n\treturn this;\n}\n\nconsole.log(foo() === window); //true\n```\n\n* 严格模式\n\n```javascript\nfunction foo() {\n    \"use strict\"//声明严格模式\n\treturn this;\n}\n\nconsole.log(foo() === undefined); //true\n```\n\n\n\n###  call(),apply()\n\n在js中可以使用call()或者apply()函数改变this的指向\n\n```javascript\nvar person = {\n    name: \"sleepy-god\",\n    age: 20\n};\n\nfunction say(job) {\n    console.log(this.name + \":\" + this.age + \"-\" + job);\n}\n\nsay.call(person, \"student\"); //sleepy-god:20-student\nsay-apply(person, [\"student\"]); //sleepy-god:20-student\n```\n\n*  Function.prototype中的call()和apply都可以改变this的指向，将this值绑定到调用中的特定对象\n*  call()与apply()作用相同，唯一的不同点就是apply()接收的参数必须时数组形式的\n\n###  bind()\n\nbind的用法与call()和apply()类似\n\n`this`将永久地被绑定到了`bind`的第一个参数，无论这个函数是如何被调用的。\n\n`function.bind(thisArg[, arg1[, arg2[, ...]]])`\n\n与call()和apply()不同的是call和apply会自动执行函数，而bind()不会，bind()会返回一个函数引用\n\n下面附上一段摘自[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility)的源码实现：\n\n```javascript\nif(!Function.prototype.bind){\n    (function() {\n        var slice = Array.prototype.slice;\n        Function.prototype.bind = function() {\n            var thatFunc = this,\n                thatArg = arguments[0];\n            var args = slice.call(arguments, 1);\n            if(typeof thatFunc !== 'function') {\n                      throw new TypeError('Function.prototype.bind - ' +\n             'what is trying to be bound is not callable');\n            }\n            return function() {\n                var funArgs = args.concat(slice.call(arguments))\n                return thatFunc.apply(thatArg, funcArgs)\n            }\n        }\n    })()\n}\n```\n\n* 将`Array.prototype.slice`赋值给变量slice\n* 将bind()传入的第一个参数`arguments[0]`记录下来，这是要绑定的this，然后将后续参数保存到args变量中\n* bind()方法返回的是一个函数，funArgs就是将bind()传入的剩余参数和后续返回的函数执行时加入的参数进行拼接\n* 然后将this指向之前的第一个参数`arguments[0]`\n\n###  关于面试中常见的手写call()和apply()方法题目\n\n浏览了不少博客和文章，发现手写call(),apply(),和bind()是比较常见的面试题目，因此我也总结了一下call()和apply()的方法\n\n####  手动实现call()方法\n\n```javascript\nFunction.prototype.myCall = function(context) {\n    if(typeof context === 'undefined' || context === null) {\n        context = window\n    }\n\n    context.fn = this;\n    let args = [...arguments].slice(1);\n    let result = context.fn(...args);\n    delete context.fn\n    return result\n}\n```\n\n####  手动实现apply()方法\n\n```javascript\nFunction.prototype.myApply = function(context) {\n    if(typeof context === 'undefined' || context === null) {\n        context = window\n    }\n\n    context.fn = this;\n    let args = arguments[1];\n    let result;\n    if(args) {\n        result = context.fn(...args)\n    } else {\n        result = context.fn()\n    }\n    delete context.fn;\n    return result\n}\n```\n\n参考链接： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind0",
    __v: NumberInt("0")
} ]);
db.getCollection("articles").insert([ {
    _id: ObjectId("5eef25069e6b3f2428acbc3f"),
    author: "幻尘",
    id: NumberInt("5"),
    title: "javaScript的执行机制（Event-Loop）",
    date: "2020.5.30",
    cate: "Js学习",
    tags: [
        "Js",
        "浏览器",
        "事件",
        "前端"
    ],
    type: "personal",
    imgUrl: "https://s1.ax1x.com/2020/05/31/tlNg6e.th.png",
    brief: "理解js的执行机制是一件至关重要的事情\n\n```javascript\nvar a = 10;\nvar b = 20;\n\nconsole.log(a);\nconsole.log(b);\n//输出： 10 20\n```\n\n当我们接触到这样的代码，我们心情舒畅，因为一眼就可以看出我们应该先执行那个步骤，再执行哪个步骤，随后我们根据需求添加了定时器\n\n```javascript\nvar a = 10;\nvar b = 20;\nsetTimeout(() => {\n  console.log(a);\n}, 1000);\nconsole.log(b);\n// 20 10\n```\n\n我们遇到了小小的麻烦，执行过程需要考虑定时器的使用，这还算可以接受，但是随着需求增加我们使用`定时器`，`async`，`promise`，`await`等等异步操作的次数也会越来越多，我们会觉得执行更加复杂，甚至心态爆炸，因此我们必须理解js的执行机制...",
    article: "---\ntop-img:\ncover: https://s1.ax1x.com/2020/05/31/tlNg6e.th.png\n\n---\n\n#  javaScript的执行机制（Event-Loop）\n\n理解js的执行机制是一件至关重要的事情\n\n```javascript\nvar a = 10;\nvar b = 20;\n\nconsole.log(a);\nconsole.log(b);\n//输出： 10 20\n```\n\n当我们接触到这样的代码，我们心情舒畅，因为一眼就可以看出我们应该先执行那个步骤，再执行哪个步骤，随后我们根据需求添加了定时器\n\n```javascript\nvar a = 10;\nvar b = 20;\nsetTimeout(() => {\n  console.log(a);\n}, 1000);\nconsole.log(b);\n// 20 10\n```\n\n我们遇到了小小的麻烦，执行过程需要考虑定时器的使用，这还算可以接受，但是随着需求增加我们使用`定时器`，`async`，`promise`，`await`等等异步操作的次数也会越来越多，我们会觉得执行更加复杂，甚至心态爆炸，因此我们必须理解js的执行机制，才能有效解决这个难以处理的问题\n\n##  javaScript的事件循环\n\n我们总会听到js是一门**单线程**语言，虽然随着语言的发展，技术大牛们也在探索**多线程**的发展，但是至今为止所有的**类似多线程**都是用单线程模拟出来的\n\n由于Js是单线程，所以正常情况下代码是顺序执行的，但是很多时候有些代码不需要直接执行，因此我们把javascript中单线程任务分为以下两类：\n\n* 同步任务\n* 异步任务\n\n###  任务队列\n\n任务队列`task Queue`，即队列，是先进先出的数据结构\n\n###  MacroTask（宏任务）\n\n* js的全部代码，`setimeout`、`setInterval`、`setImmediate`、`I/O`、`UI Rendering`\n\n###  MicroTask（微任务）\n\n* `Process.nextTick()`、`Promise`、`Object.observe(废弃)`、`MutationObserver`\n\n\n\n![](https://user-gold-cdn.xitu.io/2017/11/21/15fdd88994142347?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n从以上导图可以看出：\n\n* 同步与异步任务分别在不同场所执行，同步任务进去主线程，异步任务进入Event Table并为异步任务注册回调函数\n* 任务完成后EventTable会将任务放入EventQueue\n* 主线程内的任务执行完毕后任务队列此时为空，任务队列会读取Event Queue中的任务加入队列，进入主线程执行\n* 以上过程不断重复，即为事件循环(Event Loop)\n\njs引擎中存在monitoring process进程，它会不断地对主线程任务栈进行检查，一旦任务栈为空，则会去Event Queue检查是否有等待调用的函数\n\n###  Event Table中的执行过程\n\n执行栈在执行玩**同步任务**后，查看**执行栈**是否为空，如果执行栈为空，则查**微任务**(`microTask`)栈是否为空，如果不为空，则执行完成所有的微任务，如果为空则执行**宏任务**(`Tasks`)。\n\n每一次**宏任务**执行完毕，都检查**微任务**队列是否为空，不为空则按照出对原则（先入先出）执行所有微任务，然后设置**微任务**队列为`null`，然后执行宏任务，如此循环\n\n\n\n##  简单示例\n\n\n\n###  Ajax\n\najax技术是最常用到的数据异步数据请求技术，作为异步请求，他的执行顺序完全符合上面的流程\n\n```javascript\nlet data = [];\n$.ajax({\n    url: \"www.sleepygod.xyz\",\n    method: post,\n    data: data,\n    success: () => {\n        console.log(\"数据传输成功！\")\n    }\n})\nconsole.log(\"代码执行结束\")\n```\n\n上面的代码执行顺序就是：\n\n1. ajax为异步任务进入Event Table，注册回调函数success\n2. 顺序执行主线程任务打印 `代码执行结束`\n3. Event Table中ajax执行结束，success被放入Event Queue\n4. 主线程执行完毕，任务栈为空，主线程从Event Queue读取success函数放入主线程执行\n5. 此时打印`数据传输成功`\n\n###  setTimeout\n\n`setTimeout`是延时执行函数，同样属于异步操作，总见到有人将setTimeout的延时设置为0，其实根据HTML标准，无论怎么设置，最低标准等待时间都是4ms\n\n```javascript\nconsole.log(\"start\")\nsetTimeout(() => {\n    console.log(\"延时操作\")\n}, 3000)\nconsole.log(\"end\")\n```\n\n上面代码的执行过程是这样的：\n\n1. 打印`start`\n2. 定时器为异步操作，放入Event Table， 注册回调函数\n3. 主任务栈中执行打印`end`\n4. Event Table中定时器执行完毕，打印操作放入Event Queue\n5. 主任务栈为空，Event Table中的任务放入主线程执行，打印`延时操作`\n\n##  复杂示例\n\n```javascript\nconsole.log('script start');\n\nsetTimeout(function() {\n  console.log('setTimeout');\n}, 0);\n\nPromise.resolve().then(function() {\n  console.log('promise1');\n}).then(function() {\n  console.log('promise2');\n});\nconsole.log('script end');\n```\n\n执行上述代码时，我们先将代码进行分类：\n\n```javascript\nTasks: run script、setTimeout callback //宏任务\n\nMicroTask: Promise.then() //微任务\n\nJs stack: script\nlog: script start, script end\n```\n\n执行同步代码： 打印`script start`,`script end`划分宏任务与微任务进行详细划分\n\n```javascript\nTasks: run script、setTimeout callback //宏任务\n\nMicroTask: Promise1.then() //微任务\n\nJsTask: Promise1\nlog: script start, script end，Promise1\n```\n\n宏任务执行完毕后，任务栈为空，查询微任务，发现Promise，执行Promise，打印`promise1`，将.then()放入微任务\n\n```javascript\nTasks: run script、setTimeout callback //宏任务\n\nMicroTask: //微任务\n\nJsTask: Promise1.then()\nlog: script start, script end，Promise1, Promise2\n```\n\n继续执行微任务，打印`Promise2`,微任务栈随即清空\n\n```javascript\nTasks: setTimeout callback //宏任务\n\nMicroTask: //微任务\n\nJsTask: setTimeout callback\nlog: script start, script end，Promise1, Promise2，setTimeout\n```\n\n继续执行宏任务，执行setTimeout callback打印`setTimeout`,随即宏任务与微任务全部清空\n\n\n\n###  async/await\n\njavascript在底层已经将`async/await`转换为`promise`和`then`回调函数\n\n\n\n##  终极示例\n\n这是一个摘自掘金作者作者：[ssssyoki](https://juejin.im/post/59e85eebf265da430d571f89)文章中的例子，我研究过后才真正理解了Event Loop的机制。\n\n```javascript\nconsole.log('1');\n\nsetTimeout(function() {\n    console.log('2');\n    process.nextTick(function() {\n        console.log('3');\n    })\n    new Promise(function(resolve) {\n        console.log('4');\n        resolve();\n    }).then(function() {\n        console.log('5')\n    })\n})\nprocess.nextTick(function() {\n    console.log('6');\n})\nnew Promise(function(resolve) {\n    console.log('7');\n    resolve();\n}).then(function() {\n    console.log('8')\n})\n\nsetTimeout(function() {\n    console.log('9');\n    process.nextTick(function() {\n        console.log('10');\n    })\n    new Promise(function(resolve) {\n        console.log('11');\n        resolve();\n    }).then(function() {\n        console.log('12')\n    })\n})\n```\n\n上述代码的执行顺序如下：\n\n* 首先执行同步任务 ：\n\n  ```javascript\n  Tasks: script, setTimeout1 callback, setTimeout2 callback  //宏任务\n  \n  MicroTasks: process.nextTick1, Promise.then()//微任务\n  \n  JsTask: script\n  log: 1,7\n  ```\n\n* 同步任务执行结束查询微任务栈，发现微任务，执行微任务：\n\n  ```javascript\n  Tasks: script, setTimeout1 callback, setTimeout2 callback  //宏任务\n  \n  MicroTasks: //微任务\n  \n  JsTask: Promise.then()\n  log: 1,7，6，8\n  ```\n\n* 微任务执行结束，执行宏任务：\n\n  ```javascript\n  Tasks: setTimeout1 callback, setTimeout2 callback  //宏任务\n  \n  MicroTasks: process.nextTick, Promise.then()//微任务\n  \n  JsTask: setTimeout1 callback\n  log: 1,7，6，8,2,4\n  ```\n\n* 宏任务执行结束，查询并执行微任务：\n\n  ```javascript\n  Tasks: setTimeout1 callback, setTimeout2 callback  //宏任务\n  \n  MicroTasks: //微任务\n  \n  JsTask:  Promise.then()\n  log: 1,7，6，8,2,4，3，5\n  ```\n\n* 微任务执行结束，继续执行宏任务，发现setTimeout2:\n\n  ```javascript\n  Tasks: setTimeout2 callback  //宏任务\n  \n  MicroTasks:  process.nextTick, Promise.then()//微任务\n  \n  JsTask:  setTimeout2 callback \n  log: 1,7，6，8,2,4，3，5,9,11\n  ```\n\n* 宏任务执行结束，查询微任务，执行并清空微任务：\n\n  ```javascript\n  Tasks: setTimeout2 callback  //宏任务\n  \n  MicroTasks: //微任务\n  \n  JsTask: \n  log: 1,7，6，8,2,4，3，5,9,11,10,12\n  ```\n\n  process.nextTick属于微任务又优先于所有微任务，有process.nextTick存在时应优先执行process.nextTick。\n\n##  总结\n\njavaScript时一门单线程的语言，js的执行机制为事件循环（Event Loop），理解了这一概念将会更有利于之后与js相关知识的学习。\n\njavaScript在浏览器和node中的运行机制并不一致，以上的机制只适用于浏览器环境，并不适用于node环境^-^\n\n",
    __v: NumberInt("0")
} ]);
db.getCollection("articles").insert([ {
    _id: ObjectId("5eef254b2cc62301246012b7"),
    author: "幻尘",
    id: NumberInt("6"),
    title: "防抖与节流",
    date: "2020.5.31",
    cate: "性能优化",
    tags: [
        "Js",
        "渲染",
        "浏览器",
        "性能"
    ],
    type: "personal",
    imgUrl: "https://s1.ax1x.com/2020/06/01/t8iZon.jpg",
    brief: "第一次接触防抖与节流的概念是在一次面试中，但是当时并没有觉得防抖与节流很重要，知道后来学习vue做项目的时候才明白，防抖与节流能够有效地节省浏览器资源，因此更加深入地学习了防抖与节流的知识\n\n##  函数防抖\n\n> 当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。\n\n在一个页面中我们会发现点击一次↓键会触发很多次scroll事件，如果我们在scroll事件中添加对是否显示回到顶部按钮条件的判定，那么这时会消耗大量的浏览器资源，做很多无用功，此时我们就需要**防抖函数**的出场了...",
    article: "---\ntop_img:\ncover: https://s1.ax1x.com/2020/06/01/t8iZon.jpg\n\n---\n\n\n\n#  防抖与节流\n\n第一次接触防抖与节流的概念是在一次面试中，但是当时并没有觉得防抖与节流很重要，知道后来学习vue做项目的时候才明白，防抖与节流能够有效地节省浏览器资源，因此更加深入地学习了防抖与节流的知识\n\n##  函数防抖\n\n> 当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。\n\n在一个页面中我们会发现点击一次↓键会触发很多次scroll事件，如果我们在scroll事件中添加对是否显示回到顶部按钮条件的判定，那么这时会消耗大量的浏览器资源，做很多无用功，此时我们就需要**防抖函数**的出场了\n\n我们提出这样一种设想： 当我们触发第一次scroll事件时启动一个延时函数，如果延时时间内再次触发了scroll事件，那么此时我们重新开始计时，直到延时时间内没有再次触发该事件然后再执行事件对应的函数\n\n```javascript\nfunction debounce(fn, deplay = 1000) {\n    let timer = null;\n    return () => {\n        if(timer) clearTimeout(timer);\n        timer = setTimeout(fn, deplay)\n    }\n}\n```\n\n对于`setTimeout()`，如果我们没有给`deplay`进行赋值，将会赋予其默认值1000ms\n\n简单修改之后，代码如下：\n\n```javascript\nfunction debounce(func, deplay) {\n    let timer = null;\n    return function(...args) {\n        if(timer) clearTimeout(timer)\n        timer = setTimeout(() => {\n            func.apply(this, args)\n        }, deplay)\n    }\n}\n```\n\n**适用场景：**\n\n* 表单提交场景：可以防止多次点击提交按钮，只执行最后一次的提交操作\n* 服务端验证场景：如联想搜索，表单验证等，只执行最后一次输入后触发得到事件\n\n##  节流\n\n> 节流就是指连续触发事件，但是在n秒规定时间内只会执行一次函数\n\n节流的使用虽然带来了很多便利，但是依旧有一些情况是防抖处理不了的，例如：当一个页面在浏览器中被打开，一个用户不断上下拖动进度条，此时我们\n\n将永远不会执行scroll事件中的处理函数，因此我们需要使用另外一种策略，当用户第一次触发事件后一段时间内再次触发会失效，这也就是**节流**\n\n```javascript\nconst throttle = (func, deplay = 500) => {\n  let flag = true;\n   return (...args) => {\n    if(!flag) return;\n    flag = false;\n    setTimeout(() => {\n      func.apply(this, args);\n      flag =true\n    }, deplay)\n   }\n }\n```\n\n**代码解析：**当我们第一次触发事件时，flag=true，此时将flag设定为false即锁定函数，开始计时执行处理函数，计时期间内再次触发事件时，flag = false直接跳过所有步骤使本次触发失效\n\n通过阅读文章我还找到了另外一种方法，使使用时间戳进行判定的\n\n```javascript\nconst throttle = (func, deplay = 500) => {\n  let preTime = 0;\n  return (...args) => {\n    let now = new Date();\n    let context = this;\n    if(now - preTime > deplay) {\n      func.apply(context, args);\n      preTime = now\n    }\n  }\n}\n```\n\n**代码解析：**其实这个时间戳的版本也很好理解，每次触发事件获取一次现在的时间，如果与初次触发时间的差大于等待时间，那么执行函数，如果小于或等于即不执行\n\n\n\n**区别：**以上两种方法的区别就是，使用定时器会在延时以后执行函数，而时间戳方式是立即执行\n\n**适用场景：**\n\n* 拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动\n* 缩放场景：监控浏览器resize\n* 动画场景：避免短时间内多次触发动画引起性能问题",
    __v: NumberInt("0")
} ]);
db.getCollection("articles").insert([ {
    _id: ObjectId("5eef29c0aa5d30220c4b57b7"),
    author: "星雪工作室",
    id: NumberInt("7"),
    title: "浏览器的重绘与回流",
    date: "2020.6.1",
    cate: "性能优化",
    tags: [
        "Js",
        "渲染",
        "浏览器",
        "性能"
    ],
    type: "team",
    imgUrl: "https://s1.ax1x.com/2020/06/01/t8F49x.png",
    brief: "这是我在之前面试中遇到的一个问题，今天回想起来正好做一个总结\n\n###  浏览器在将页面展示给我们之前都做了什么（渲染机制）\n\n这其实也是我遇到的一道面试题，与重绘和回流息息相关\n\n1. 用户输入网址\n2. 浏览器通过DNS获取网站的IP地址\n3. 浏览器尝试与服务器建立连接\n4. 服务器发送永久重定向\n5. 浏览器跟踪重定向地址\n6. 服务器处理请求\n7. 服务器发送HTML响应\n8. 浏览器接收响应，开始解析\n9. 解析`html`文件，处理并创建`DOM`树\n10. 解析`css`样式表， 构建`C...",
    article: "---\ntop-img:\ncover: https://s1.ax1x.com/2020/06/01/t8F49x.png\n\n---\n\n***\n\n## 浏览器的重绘与回流\n\n这是我在之前面试中遇到的一个问题，今天回想起来正好做一个总结\n\n###  浏览器在将页面展示给我们之前都做了什么（渲染机制）\n\n这其实也是我遇到的一道面试题，与重绘和回流息息相关\n\n1. 用户输入网址\n2. 浏览器通过DNS获取网站的IP地址\n3. 浏览器尝试与服务器建立连接\n4. 服务器发送永久重定向\n5. 浏览器跟踪重定向地址\n6. 服务器处理请求\n7. 服务器发送HTML响应\n8. 浏览器接收响应，开始解析\n9. 解析`html`文件，处理并创建`DOM`树\n10. 解析`css`样式表， 构建`CSSOM`树\n11. 将`DOM`与`CSSOM`进行结合，构建渲染树(Render Tree)\n12. 根据渲染树来布局(<font color=\"blue\">layout</font>)，计算每一个节点的位置\n13. 调用GPU进行绘制(<font color=\"blue\">Paint</font>)，合成图层\n14. 重绘(<font color=\"blue\">repaint</font>)与回流(<font color=\"blue\">reflow</font>)\n\n当html解析遇到`script`时会暂停构建DOM，执行js脚本，执行完毕后才会继续构建DOM树，因此将js文件放在html文件底部进行加载才会节省加载时间，加快绘制速度\n\n\n\n浏览器使用流式布局 (Flow Based Layout)，对`Render Tree`的计算通常只需要遍历一次就可以完成，但`table`及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用`table`布局的原因之一\n\n***\n\n###  重绘与回流\n\n<font color=\"red\">回流必将引起重绘，而重绘不一定引起回流</font>\n\n####  回流\n\n当`Render Tree`中部分或全部元素的尺寸、结构、布局、隐藏等发生改变而需要重新构建，浏览器因此重新渲染的过程叫做<font color=\"red\">回流</font>\n\n会导致回流的操作：\n\n* 页面的首次渲染\n* 浏览器窗口哦的大小发生改变\n* 元素的尺寸或位置发生改变\n* 元素的内容发生变化\n* 元素样式发生改变（字体、隐藏等）\n* 激活CSS伪类(`:after`,`:before`,`:hover`等)\n* 调用某些方法\n\n常用且会导致回流的属性和方法\n\n* `clientWidth`、`clientHeight`、`clientTop`、`clientLeft`\n* `offsetWidth`、`offsetHeight`、`offsetTop`、`offsetLeft`\n* `scrollWidth`、`scrollHeight`、`scrollTop`、`scrollLeft`\n* `scrollIntoView()`、`scrollIntoViewIfNeeded()`\n* `getComputedStyle()`\n* `getBoundingClientRect()`\n* `scrollTo`\n\n####  重绘\n\n当页面元素的样式发生改变且并不影响它在文档中的位置时，浏览器将根据其新属性进行重新绘制，这个过程就是<font color=\"red\">重绘</font>\n\n\n\n####  性能影响\n\n**<font color=\"red\">回流比重绘更加影响性能，付出代价更高</font>**\n\n有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。\n\n现代浏览器会对频繁的回流或重绘操作进行优化：\n\n浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。\n\n\n\n####  避免的方法\n\n#####  css\n\n*  避免使用`table`布局\n*  尽可能在`DOM`的末端改变`class`\n*  避免使用多层内联样式\n*  将动画效果应用到`position`属性为`absolute`或`fixed`的元素上\n*  避免使用`css`表达式（例如:`calc()`）\n\n#####  JS\n\n*  避免频繁地操作样式，尽可能地一次性重写style属性\n*  避免频繁操作DOM，可以创建一个`documentFragment`,在其上完成所有DOM操作，然后将其加入到文档中\n*  也可以先为元素设置`display: none`，操作结束后再把它显示出来。因为在`display`属性为`none`的元素上进行的`DOM`操作不会引发回流和重绘。\n*  避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。\n*  对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。\n\n",
    __v: NumberInt("0")
} ]);
db.getCollection("articles").insert([ {
    _id: ObjectId("5eef2a3b5590df2e609572ec"),
    author: "星雪工作室",
    id: NumberInt("8"),
    title: "我所理解的JavaScript的深浅拷贝",
    date: "2020.6.2",
    cate: "Js学习",
    tags: [
        "Js",
        "ES6",
        "底层"
    ],
    type: "team",
    imgUrl: "https://s1.ax1x.com/2020/06/02/tYnhqI.th.jpg",
    brief: "这并不是我第一次解除这个话题，但是这是我第一次深入地对javaScript的深浅拷贝机制进行学习\n\n##  数据类型\n\n我们都知道javaScript拥有很多数据类型我们将他们分为两种：\n\n* 基本数据类型\n* 引用数据类型\n\n基本数据类型包括： String, Number, Boolean, undefined, null, symbol(<font color=\"blue\">Es6专属</font>) \n\n引用数据类型包括： Object（对象）、Array（数组）、Function（函数）\n\n对...",
    article: "---\ntop-img:\ncover: https://s1.ax1x.com/2020/06/02/tYnhqI.th.jpg\n\n---\n\n\n\n#  我所理解的JavaScript的深浅拷贝\n\n这并不是我第一次解除这个话题，但是这是我第一次深入地对javaScript的深浅拷贝机制进行学习\n\n##  数据类型\n\n我们都知道javaScript拥有很多数据类型我们将他们分为两种：\n\n* 基本数据类型\n* 引用数据类型\n\n基本数据类型包括： String, Number, Boolean, undefined, null, symbol(<font color=\"blue\">Es6专属</font>) \n\n引用数据类型包括： Object（对象）、Array（数组）、Function（函数）\n\n对于基本数据类型来说，变量直接按值存放在栈内存的简单数据段中，可以直接进行访问，因此并不存在深浅拷贝的区别，\n\n引用类型存放在堆内存中，变量保存的是一个指针，当我们需要访问引用类型的值的时候，首先从栈中获得该对象的地址指针，然后从堆中取得需要的数据\n\n##  浅拷贝\n\n什么是浅拷贝？\n\n答： 浅拷贝就是只复制了引用，而没有复制真正的值，浅拷贝会使两者指向同一块内存空间\n\n使用`=`进行浅拷贝是我们做常用的操作\n\n```javascript\nconst originArray = [1,2,3,4];\nconst originObj = {name: 'a', age: 30, favorite: {obj: 'sing'}};\n\nconst cloneArray = originArray; \nconst cloneObj = originObj;\n\nconsole.log(cloneArray); // [1,2,3,4]\nconsole.log(cloneObj); // {name: 'a', age: 30, favorite: {obj: 'sing'}}\n\ncloneArray.push(6);\nconsole.log(originArray); // [1,2,3,4,6]\nconsole.log(cloneArray); // [1,2,3,4,6]\n\ncloneObj.name = 'b';\nconsole.log(originObj); // {name: 'b', age: 30, favorite: {obj: 'sing'}}\nconsole.log(cloneObj); // {name: 'b', age: 30, favorite: {obj: 'sing'}}\n\nconsole.log(originObj === cloneObj) //true\n```\n\n以上代码使用了`=`进行了浅拷贝操作，`clone***`和`origin***`指向的是同一块内存空间，因此一个引用的值发生改变时，代表着两个对象的值全都被修改了\n\n##  深拷贝\n\n不同于浅拷贝，深拷贝是对目标的完全拷贝，深拷贝并不只是复制了引用，而是将值也一并复制，使用了新的内存空间，成为新的数据，与旧数据互不影响\n\n常用的深拷贝方法：\n\n* 利用`JSON`对象的`parse`和`stringify`\n* 利用递归实现对每一层次的重新创建和赋值\n\n###  JSON.stringify()和JSON.parse()方法\n\n他们都是做什么的呢？\n\n> The **`JSON.parse()`** method parses a JSON string, constructing the JavaScript value or object described by the string. An optional **reviver** function can be provided to perform a transformation on the resulting object before it is returned.\n\n`JSON.parse()`是将一个`JSON`字符串转换为`Javascript`值或对象\n\n> The **`JSON.stringify()`** method converts a JavaScript object or value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.\n\n`JSON.stringify()`是将一个`JavaScript`值转换为`JSON`字符串\n\n多说无益直接代码分析：\n\n```javascript\nlet originArr = [1,2,3,4];\nlet cloneArr = JSON.parse(JSON.stringify(originArr));\n\ncloneArr.push(6);\n\nconsole.log(originArr); //[ 1, 2, 3, 4 ]\nconsole.log(cloneArr); //[ 1, 2, 3, 4, 6 ]\n\n```\n\n可以看出进行深拷贝之后，原数组的值并没有因为新的数组值改变而改变，十分方便\n\n但是这种方法也是有一定缺点的：\n\n```javascript\nconst originObj = {\n  name:'axuebin',\n  sayHello:function(){\n    console.log('Hello World');\n  }\n}\nconsole.log(originObj); // {name: \"axuebin\", sayHello: ƒ}\nconst cloneObj = JSON.parse(JSON.stringify(originObj));\nconsole.log(cloneObj); // {name: \"axuebin\"}\n```\n\n此时发现`sayHello`并没有被加入到`cloneObj`中，多方查阅发现`MDN`有所规定：\n\n> If undefined, a function, or a symbol is encountered during conversion it is either omitted (when it is found in an object) or censored to null (when it is found in an array). JSON.stringify can also just return undefined when passing in \"pure\" values like JSON.stringify(function(){}) or JSON.stringify(undefined).\n\n使用上述方法时`function`、`undefined`、`symbol`会被自动忽略，因此当我们的原对象中含有函数时我们不能使用这种方法进行深拷贝\n\n###  递归方法实现深拷贝\n\n```javascript\nfunction deepClone(oldObj) {\n  const newObj = oldObj.constructor === Array ? [] : {};//判断目标为数组还是对象并\n  for(let key in oldObj) {\n    if(oldObj.hasOwnProperty(key)) {\n      if(oldObj[key] && typeof oldObj[key] === 'object') {\n        newObj[key] = deepClone(oldObj[key])\n      } else {\n        newObj[key] = oldObj[key]\n      }\n    }\n  }\n  \n  return newObj\n}\n```\n\n用以下方法验证一下\n\n```javascript\nlet oldObj = {\n  name: 'a',\n  b: {\n    age: 20,\n    favorite: 'coding'\n  },\n  sayHello() {\n    console.log('Hello')\n  }\n};\nlet newObj = deepClone(oldObj);\n\nnewObj.b.age = 19;\n\nconsole.log(oldObj); //{ name: 'a', b: { age: 20, favorite: 'coding' }, sayHello: [Function: sayHello] }\nconsole.log(newObj); //{ name: 'a', b: { age: 19, favorite: 'coding' }, sayHello: [Function: sayHello] }\n```\n\n经过验证这个函数完美实现了深拷贝\n\n###  Object.assign()\n\n先来看一下[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)对于这个函数的解释\n\n> The **`Object.assign()`** method copies all [enumerable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable) [own properties](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty) from one or more *source objects* to a *target object*. It returns the target object.\n\n`Object.assgin()`方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。\n\n```javascript\nvar x = {\n  a: 1,\n  b: { f: { g: 1 } },\n  c: [ 1, 2, 3 ]\n};\nvar y = Object.assgin({}, x);\nconsole.log(y.b.f === x.b.f) //true\n\nvar x = {\n  a: 1,\n  b: { f: { g: 1 } },\n  c: [ 1, 2, 3 ]\n};\nvar y = Object.assign({}, x);\nconsole.log(y.b.f === x.b.f) //true\nconsole.log(x); //{ a: 1, b: { f: { g: 1 } }, c: [ 1, 2, 3 ] }\nconsole.log(y); //{ a: 1, b: { f: { g: 1 } }, c: [ 1, 2, 3 ] }\n\nx.a = 2;\nx.b.f.g = 2；\nconsole.log(x); //{ a: 2, b: { f: { g: 2 } }, c: [ 1, 2, 3 ] }\nconsole.log(y) //{ a: 1, b: { f: { g: 2 } }, c: [ 1, 2, 3 ] }\n```\n\n由上述代码可知`Object.assgin`仅仅只是对源对象的第一层进行了深拷贝，而对于内层以及更深层次的对象却只是进行了浅拷贝\n\n###  concat\n\n> The **`concat()`** method is used to merge two or more arrays. This method does not change the existing arrays, but instead returns a new array.\n\n `concat()` 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。\n\n开起来是对源数组进行了一次深拷贝，具体状况我们可以试一下：\n\n```javascript\nconst originArr = [1,2,3,4];\nconst cloneArr = originArr.concat();\n\nconsole.log(originArr === cloneArr); //false\noriginArr.push(6);\nconsole.log(originArr); // [1,2,3,4,6]\nconsole.log(cloneArr) // [1,2,3,4]\n\noriginArr.push([1,5,4]);\nconst cloneArr2 = originArr.concat();\nconsole.log(originArr); //[ 1, 2, 3, 4, 6, [ 1, 5, 4 ] ]\nconsole.log(cloneArr2) // [ 1, 2, 3, 4, 6, [ 1, 5, 4 ] ]\noriginArr[5].push(6)\nconsole.log(originArr); //[ 1, 2, 3, 4, 6, [ 1, 5, 4, 6 ] ]\nconsole.log(cloneArr2) // [ 1, 2, 3, 4, 6, [ 1, 5, 4, 6 ] ]\n```\n\n**由此可见`concat`也仅仅只是对源数组的第一层进行了深拷贝**\n\n###  slice\n\n> The **`slice()`** method returns a shallow copy of a portion of an array into a new array object selected from `begin` to `end` (`end` not included) where `begin` and `end` represent the index of items in that array. The original array will not be modified.\n\n在[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)的定义中已经明确写了**shallow copy**，但是通过阅读**[axuebin](https://github.com/axuebin)**博客文章我发现`slice`方法的确不是完全的浅拷贝\n\n\n\n```javascript\nconst originArr = [1, 2, 3, 4, [5, 6, 7, 8]];\nconst cloneArr = originArr.slice();\n\noriginArr.push(9);\nconsole.log(originArr); //[ 1, 2, 3, 4, [ 5, 6, 7, 8 ], 9 ]\nconsole.log(cloneArr); //[ 1, 2, 3, 4, [ 5, 6, 7, 8 ] ]\n```\n\n**通过实验证明，`Array.prototype.slice()`的确并非全部浅拷贝，而是对源数组的第一层进行了深拷贝！**\n\n###  问题解析\n\n为什么会出现只对第一层进行了深拷贝的情况呢？\n\n答：因为在数组或对象中，对内层或跟深层的数组或对象都是存储了一个指针引用，而这些函数在底层实现时都是直接将第一层的数据和引用拷贝下来，因此就形成了只有首层是深拷贝的情况。\n\n##  总结\n\n* 对于 `=`赋值运算符来说，仅仅是进行了浅拷贝，只是拷贝了对象或数组的引用\n* `JSON.stringify()`实现了深拷贝，但是会自动省略源对象中的`undefined`、`function`、`symbol`\n* 其他js中的函数大多数都只是实现了首层的深拷贝和内层的浅拷贝\n* 递归方法是实现完全深拷贝最简单有效的方法",
    __v: NumberInt("0")
} ]);
db.getCollection("articles").insert([ {
    _id: ObjectId("5eef2a737420560cc86b9bee"),
    author: "星雪工作室",
    id: NumberInt("9"),
    title: "BFC小结",
    date: "2020.6.3",
    cate: "CSS学习",
    tags: [
        "css",
        "样式",
        "布局",
        "渲染"
    ],
    type: "team",
    imgUrl: "https://s1.ax1x.com/2020/06/03/tNxUIA.th.jpg",
    brief: "之前并没有系统地了解过什么是BFC以及它有什么作用，学习之后才发现以前遇到的很多问题都是可以使用BFC解决的\n\n##  什么是BFC\n\n> W3C对BFC的定义如下： 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为\"visiable\"的块级盒子，都会为他们的内容创建新的BFC（Block Fromatting Context，",
    article: "---\ntop-img:\ncover: https://s1.ax1x.com/2020/06/03/tNxUIA.th.jpg\n\n---\n\n# BFC小结\n\n之前并没有系统地了解过什么是BFC以及它有什么作用，学习之后才发现以前遇到的很多问题都是可以使用BFC解决的\n\n##  什么是BFC\n\n> W3C对BFC的定义如下： 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为\"visiable\"的块级盒子，都会为他们的内容创建新的BFC（Block Fromatting Context， 即块级格式上下文）\n\n我们常说的文档流其实分为定位流、浮动流和普通流三种，而普通流其实就是指**BFC**中的**FC**\n\n**FC**是formating context的缩写，也就是格式化上下文，决定了其子元素如何布局以及与其他元素之间的关系\n\n常见的**FC**有BFC（块级格式化上下文）、IFC（行级格式化上下文）、GFC（网格布局格式化上下文）和FFC（自适应格式化上下文）\n\n**BFC**是通过一些特定的属性设置而使元素脱离普通流的束缚形成完全独立的区域，且内部元素与外部元素不会产生相互影响\n\n##  BFC的触发条件\n\n**BFC**的触发条件有下列几种：\n\n* 根元素，即HTML元素\n* 浮动元素： float 不为 none\n* 绝对定位元素：position 设置为 absolute 或 fixed\n* 行内块级元素：display 设置为 inline-block\n* 表格单元格：display 设置为 table-cell\n* 表格标题： display 设置为 table-caption\n* overflow 值不为 visible 的块元素 - 弹性盒元素(flex)\n* 网格元素：display为grid 或 inline-grid 元素的直接子元素\n\n##  BFC的布局规则\n\n* 内部的Box会在垂直方向一个接一个地进行放置\n* 属于同一个BFC的两个Box的margin会发生重叠\n* BFC区域不会与float的box重叠\n* BFC是一个独立的容器，内部元素不会与外部元素产生相互影响\n* 计算BFC高度时浮动元素也会参与计算\n\n##  应用场景\n\n###  解决父元素塌陷问题\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>BFCtest</title>\n  <style type=\"text/css\">\n    * {\n      margin: 0;\n      padding: 0;\n    }\n\n    .father {\n      border: 5px solid lightskyblue;\n    }\n\n    .child {\n      width: 100px;\n      height: 100px;\n      background-color: red;\n    }\n  </style>\n</head>\n<body>\n<div class=\"father\">\n  <div class=\"child\"></div>\n</div>\n</body>\n</html>\n```\n\n![t1DgfA.png](https://s1.ax1x.com/2020/05/31/t1DgfA.png)\n\n将内部child设置为浮动\n\n```css\n.child {\n  width: 100px;\n  height: 100px;\n  background-color: red;\n  float: left;\n}\n```\n\n![t1r9k4.jpg](https://s1.ax1x.com/2020/05/31/t1r9k4.jpg)\n\n此时发现父元素发生了塌陷，这是将父元素设置为BFC这样就解决了父元素塌陷的问题\n\n```css\n.father {\n  border: 5px solid lightskyblue;\n  overflow: hidden;\n}\n```\n\n###  避免外边距重叠\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>同一BFC外边距重叠</title>\n  <style type=\"text/css\">\n    * {\n      margin: 0;\n      padding: 0;\n    }\n    .container {\n      background-color: lightskyblue;\n      overflow: hidden;\n    }\n\n    .inner {\n      background-color: coral;\n      margin: 10px 0;\n      text-align: center;\n    }\n  </style>\n</head>\n<body>\n<div class=\"container\">\n  <div class=\"inner\">1</div>\n  <div class=\"inner\">2</div>\n  <div class=\"inner\">3</div>\n</div>\n</body>\n</html>\n```\n\n<img src=\"https://s1.ax1x.com/2020/05/31/t1yrwT.jpg\" alt=\"t1yrwT.jpg\" style=\"zoom:60%;\" />\n\n我们会发现每两个inner元素之间的间距都是10px，这是因为外层container元素为BFC，所以内部子元素发生了margin重叠，我们BFC内部与外部是不会相互影响的，那么这时我们将内部元素封装进BFC中那么就不会出现margin重叠的情况了\n\n```html\n<div class=\"container\">\n  <div class=\"inner\">1</div>\n  <div class=\"bfc\">\n    <div class=\"inner\">2</div>\n  </div>\n  <div class=\"inner\">3</div>\n</div>\n```\n\n```css\n.bfc {\n  overflow: hidden;\n}\n```\n\n<img src=\"https://s1.ax1x.com/2020/05/31/t1cYxs.jpg\" alt=\"t1cYxs.jpg\" style=\"zoom:60%;\" />\n\n这时就会发现`2`对应的元素上下边距已经不再重合了\n\n\n\n\n\n##  总结\n\n以上就是我学习BFC的内容，示例来源于[神三元](http://47.98.159.95/my_blog/css/008.html)大佬的博客，BFC的概念相对抽象，但是通过这些示例能够清除地了解BFc的重要性，同时我也参考了另外两篇文章[[布局概念] 关于CSS-BFC深入理解](https://juejin.im/post/5909db2fda2f60005d2093db)、[学习 BFC (Block Formatting Context)](https://juejin.im/post/59b73d5bf265da064618731d)\n\n##  后话\n\n致力于做一个有灵魂的搬运工！！！！\n\n至此完成了我给自己规定的5日学习目标，明天开始更新算法、Vue源码、Js高级进阶等相关的内容！",
    __v: NumberInt("0")
} ]);
db.getCollection("articles").insert([ {
    _id: ObjectId("5eef2a966013bf0ebcde10e4"),
    author: "星雪工作室",
    id: NumberInt("10"),
    title: "Vue学习笔记 -- Vue的响应式原理",
    date: "2020.6.5",
    cate: "Vue学习笔记",
    tags: [
        "Vue.js",
        "原理",
        "响应式"
    ],
    type: "team",
    imgUrl: "https://s1.ax1x.com/2020/06/04/tw0mOe.th.jpg",
    brief: "今天通过王红元老师的教学视频和一些博主的技术分享，学习了Vue的响应式原理，话不多说直接进入正题\n\n![alt 图片](https://cn.vuejs.org/images/data.png)\n\n这是Vue官网中提供的响应式原理示意图，总结起来我们最常见到的响应式原理的答案就是： \n\n<font color=\"red\">使用Object.defineProperty将所有属性使用setter和getter进行劫持，在读取数据和写入数据时进行拦截处理</font>\n\n这是我自己总结的响应式流程...",
    article: "---\ntop-img:\ncover: https://s1.ax1x.com/2020/06/04/tw0mOe.th.jpg\n\n---\n\n***\n\n## Vue学习笔记 -- Vue的响应式原理\n\n今天通过王红元老师的教学视频和一些博主的技术分享，学习了Vue的响应式原理，话不多说直接进入正题\n\n![alt 图片](https://cn.vuejs.org/images/data.png)\n\n这是Vue官网中提供的响应式原理示意图，总结起来我们最常见到的响应式原理的答案就是： \n\n<font color=\"red\">使用Object.defineProperty将所有属性使用setter和getter进行劫持，在读取数据和写入数据时进行拦截处理</font>\n\n这是我自己总结的响应式流程：\n\n![tlNclD.png](https://s1.ax1x.com/2020/05/31/tlNclD.png)\n\n然而这只是响应式原理中的一小部分，下面时是我用自己的话总结的响应式原理：\n\n<font color=\"red\">Vue的响应式原理是通过使用订阅者-发布者模式，配合Object.defineProperty将所有data中的属性进行写入与 获取的劫持，将每一个属性对应一个Dep对象，解析并存储某一属性所对应的vm实例，当属性值发生改变时，Watcher会通知该属性所关联的所有vm实例进行数据更新，者就是响应式的基本原理</font>\n\n###  一、什么是Object.defineProperty\n\n`Object.defineProperty(obj, prop, descriptor)`是js对象操作的常用api之一，他对应的三个参数分别是： 需要被定义属性的对象， 要定义或修改的属性，数据描述符或存取描述符\n\n**configurable**\n\n​\t当且仅当该属性的 `configurable` 键值为 `true` 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除\n\n**enumerable**\n\n​\t当且仅当该属性的 `enumerable` 键值为 `true` 时，该属性才会出现在对象的枚举属性中。\n\n**value**\n\n​\t该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。\n\n**writable**\n\n​\t当且仅当该属性的 `writable` 键值为 `true` 时，属性的值，也就是上面的 `value`，才能被赋值运算符改变。\n\n**get**\n\n​\t属性的 getter 函数，如果没有 getter，则为 `undefined`。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 `this` 对象（由于继承关系，这里的`this`并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。\n\n**set**\n\n​\t属性的 setter 函数，如果没有 setter，则为 `undefined`。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 `this` 对象。\n\n***\n\n###  二、什么是订阅者-发布者模式\n\n订阅者-发布者模式简单来说就是：\n\n当我们使用微信关注公众号后，公众号会定期想你推送新消息，在这个场景下我们就是**订阅者**而公众号就是**发布者**\n\n我们先定义一个发布者的对象：\n\n```javascript\n  class Dep {\n    constructor() {\n      //订阅者\n      this.subscribs = []\n    }\n\n    addSub(sub) {\n      this.subscribs.push(sub)\n    }\n\n    notify() {\n        //对订阅者进行遍历，逐一通知修改\n      this.subscribs.forEach(item => {\n        item.update()\n      })\n    }\n  }\n```\n\n接下来我们定义数个订阅者\n\n```javascript\n  var sub1 = {\n    update() {\n      console.log('sub1发生改变')\n    }\n  }\n  var sub2 = {\n    update() {\n      console.log('sub2发生改变')\n    }\n  }\n  var sub3 = {\n    update() {\n      console.log('sub3发生改变')\n    }\n  }\n```\n\n定义之后我们将所有订阅者存入发布者对象中，然后进行发布\n\n```javascript\n  var dep = new Dep();\n  dep.add(sub1);\n  dep.add(sub2);\n  dep.add(sub3);\n\n  dep.notify();\n```\n\n这样dep就会通知已经进行订阅的用户进行数据修改并更新视图，也就完成了发布者的基本功能\n\n这里我们直接定义一个订阅者：\n\n```javascript\n  class Watcher {\n    constructor(node, name, vm) {\n      this.node = node;\n      this.name = name;\n      this.vm = vm;\n      Dep.target = this;\n      this.update();\n      Dep.target = null;\n    }\n\n    update() {\n      this.node.nodeValue = this.vm[this.name] //get\n    }\n  }\n```\n\n当数据发生改变时，直接使用`new Watcher(node, name, this.vm)`对数据进行修改\n\n***\n\n###  三、响应式原理\n\n在Vue中我们应该先定义一个Vue的对象\n\n```javascript\n  class Vue {\n    constructor(options) {\n      this.$options = options;\n      this.$data = options.data;\n      this.$el = options.el;\n\n      //  先将data挂载到响应式系统中\n      new Observe(this.$data);\n    }\n  }\n```\n\n创建发布者对象\n\n```javascript\n  class Dep {\n    constructor() {\n      //订阅者\n      this.subscribs = []\n    }\n\n    addSub(sub) {\n      this.subscribs.push(sub)\n    }\n\n    notify() {\n        //对订阅者进行遍历，逐一通知修改\n      this.subscribs.forEach(item => {\n        item.update()\n      })\n    }\n  }\n```\n\n\n\n定义一个Observe对象，对data中的属性进行劫持\n\n```javascript\n class Observe {\n    constructor(data) {\n      this.data = data;\n      Object.keys(this.data).forEach(key => {\n        this.defineReactive(this.data, key, data[key])\n      })\n    }\n    defineReactive(data, key, val) {\n      const dep = new Dep();\n      Object.defineProperty(data, key, {\n        configurable: true,\n        enumerable: true,\n        set(newValue) {\n          if(newValue === val) {\n            return\n          }\n          val = newValue;\n            //通知修改属性\n          dep.notify()\n        },\n        get() {\n          if(Dep.target) {\n            dep.addSub(Dep.target)\n          }\n          return val\n        }\n      })\n    }\n  }\n```\n\n将data中的所有属性使用proxy进行代理\n\n```javascript\n  class Vue {\n    constructor(options) {\n      this.$options = options;\n      this.$el = options.el;\n      this.$data = options.data;\n\n      //将数据挂载到响应式系统\n      new Observe(this.$data)\n        \n\t  //将data代理到this中\n      Object.keys(this.$data).forEach(key => {\n        this._proxy(key)\n      })\n    }\n\n    _proxy(key) {\n      Object.defineProperty(this, key, {\n        configurable: true,\n        enumerable: true,\n        set(newValue) {\n          this.$data[key] = newValue\n        },\n        get() {\n          return this.$data[key]\n        }\n      })\n    }\n  }\n```\n\n配置订阅者对象\n\n```javascript\n  class Watcher {\n    constructor(node, name, vm) { //节点， 属性名， Vue实例\n      this.node = node;\n      this.name = name;\n      this.vm = vm;\n      Dep.target = this;\n      this.update();\n      Dep.target = null\n    }\n\n    update() {\n      //修改视图数据\n      this.node.nodeValue = this.vm[this.name]\n    }\n  }\n```\n\n配置正则处理规则\n\n```javascript\nconst reg = /\\{\\{(.*)\\}\\}/; //{{}}\n```\n\n配置视图解析对象\n\n```javascript\n  class Compiler {\n    constructor(el, vm) {\n      this.el = document.querySelector(el);\n      this.vm = vm;\n\n      this.frag = this._createFragment();\n      //视图解析创建虚拟节点时会将原节点删除，因此需要重新加入节点\n      this.el.appendChild(this.frag)\n    }\n     //创建虚拟节点并对原节点进行解析处理\n    _createFragment() {\n      //创建虚拟dom根节点\n      const frag = document.createDocumentFragment()\n\n      let child;\n      //循环搜索节点，解析视图\n      while(child = this.el.firstChild) {\n        this._compile(child);\n        frag.appendChild(child)\n      }\n      return frag\n    }\n    //对节点进行解析，并且添加监听和视图修改操作\n    _compile(node) {\n      console.log(node);\n      if(node.nodeType === 1){ //标签节点\n        const attrs = node.attributes;\n        if(attrs.hasOwnProperty('v-model')) {\n          const name = attrs['v-model'].nodeValue;\n          node.addEventListener('input', e => {\n            this.vm[name] = e.target.value;\n          })\n        }\n      }\n\n      if(node.nodeType === 3) {\n        console.log(\"node: \" + node.nodeValue);\n        console.log(reg.test(node.nodeValue));\n        if (reg.test(node.nodeValue)) {\n          const name = RegExp.$1.trim()\n          console.log('name: ' + name);\n          new Watcher(node, name, this.vm)\n        }\n      }\n    }\n  }\n```\n\n完善Vue对象的创建过程\n\n```javascript\n class Vue {\n    constructor(options) {\n      this.$options = options;\n      this.$el = options.el;\n      this.$data = options.data;\n\n      //将数据挂载到响应式系统\n      new Observe(this.$data);\n\t// 将data进行代理处理\n      Object.keys(this.$data).forEach(key => {\n        this._proxy(key)\n      });\n\n    //  将el进行解析并添加订阅者\n      new Compiler(this.$el, this)\n    }\n```\n\n###  总结\n\n总结起来响应式的过程大致如下：\n\n*  定义Vue对象，将Vue对象中的data属性值进行响应式挂载， Observe\n*  在Observe中对每一个属性进行劫持处理，添加setter和getter方法,，在watcher的 update()方法被调用时，会自动执行getter方法，此时将这个Watcher对象（即订阅者）添加到发布者中\n*  每当数据变化时就会触发该属性对应的Dep对象中的notify()方法，通知所有成员进行数据更新\n*  订阅者此时触发update()方法，改变了Watcher中对应node的nodeValue，也就是视图显示的数据\n*  就这样形成了数据的双向绑定，即视图值修改，数据值即修改，反之亦然\n\n",
    __v: NumberInt("0")
} ]);
db.getCollection("articles").insert([ {
    _id: ObjectId("5eef2ac6b46ea4083cbbddf6"),
    author: "星雪工作室",
    id: NumberInt("11"),
    title: "Vue学习笔记 ---- 虚拟DOM",
    date: "2020.6.7",
    cate: "Vue学习笔记",
    tags: [
        "Vue.js",
        "原理",
        "虚拟DOM",
        "diff算法"
    ],
    type: "team",
    imgUrl: "https://s1.ax1x.com/2020/06/04/tw0mOe.th.jpg",
    brief: "什么是虚拟DOM\n\n随着时代的发展，页面上的功能越来越多，程序中需要维护的状态越来越多，DOM操作也越来越频繁\n\n我们发现像之前那样使用jQuery或原生js来开发页面，那么操作DOM的代码占据大多数，程序中的状态也难以进行管理，这被称为**命令式操作DOM**，虽然简单实用，但是却难以进行维护。\n\n当我们开始使用三大主流框架Vue.js、Angular和React时，他们都是声明式地操作DOM，我们通过描述状态与DOM之间的映射关系，就可以将状态转换为视图，甚至我们根本不需要手动操作DOM\n\n<font color=\"red\">**我们的关注点应该聚焦在状态维护上...",
    article: "---\ntop-img:\ncover: https://s1.ax1x.com/2020/06/04/tw0mOe.th.jpg\n\n---\n\n#  Vue学习笔记 ---- 虚拟DOM\n\n##  什么是虚拟DOM\n\n随着时代的发展，页面上的功能越来越多，程序中需要维护的状态越来越多，DOM操作也越来越频繁\n\n我们发现像之前那样使用jQuery或原生js来开发页面，那么操作DOM的代码占据大多数，程序中的状态也难以进行管理，这被称为**命令式操作DOM**，虽然简单实用，但是却难以进行维护。\n\n当我们开始使用三大主流框架Vue.js、Angular和React时，他们都是声明式地操作DOM，我们通过描述状态与DOM之间的映射关系，就可以将状态转换为视图，甚至我们根本不需要手动操作DOM\n\n<font color=\"red\">**我们的关注点应该聚焦在状态维护上，而DOM操作其实是可以省略的**</font>\n\n当某个状态发生改变时，只更新与它相关的DOM节点，为了解决这个问题，主流框架都有着自己的一套解决方案，Angular中使用脏检查的流程，React中使用的是虚拟DOM，Vue1.0使用细粒度的绑定\n\n虚拟DOM的解决方式是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染，渲染之间会将新旧虚拟节点树进行对比，只渲染不一样的地方\n\n使用虚拟节点进行DOM操作有效提高了性能\n\n虚拟DOM在Vue.js中只做了两件事：\n\n* 提供与真实DOM节点对应的虚拟节点vnode\n* 将虚拟节点**vnode**与旧虚拟节点**oldVnode**进行对比，然后进行视图更新\n\n两个虚拟节点进行对比是虚拟DOM中最核心的算法**patch**，它可以判断出哪些节点发生了变化，从而进行节点更新操作\n\n\n\n##  VNode\n\nVue.js中存在一个**VNode**类，可以用来实例化不同类型的vnode实例，而不同类型的vnode实例各自代表着不同的DOM元素\n\n先来看一下VNode的定义源码：\n\n```javascript\nexport default class VNode {\n  tag: string | void;\n  data: VNodeData | void;\n  children: ?Array<VNode>;\n  text: string | void;\n  elm: Node | void;\n  ns: string | void;\n  context: Component | void; // rendered in this component's scope\n  key: string | number | void;\n  componentOptions: VNodeComponentOptions | void;\n  componentInstance: Component | void; // component instance\n  parent: VNode | void; // component placeholder node\n\n  // strictly internal\n  raw: boolean; // contains raw HTML? (server only)\n  isStatic: boolean; // hoisted static node\n  isRootInsert: boolean; // necessary for enter transition check\n  isComment: boolean; // empty comment placeholder?\n  isCloned: boolean; // is a cloned node?\n  isOnce: boolean; // is a v-once node?\n  asyncFactory: Function | void; // async component factory function\n  asyncMeta: Object | void;\n  isAsyncPlaceholder: boolean;\n  ssrContext: Object | void;\n  fnContext: Component | void; // real context vm for functional nodes\n  fnOptions: ?ComponentOptions; // for SSR caching\n  devtoolsMeta: ?Object; // used to store functional render context for devtools\n  fnScopeId: ?string; // functional scope id support\n\n  constructor (\n    tag?: string,\n    data?: VNodeData,\n    children?: ?Array<VNode>,\n    text?: string,\n    elm?: Node,\n    context?: Component,\n    componentOptions?: VNodeComponentOptions,\n    asyncFactory?: Function\n  ) {\n    this.tag = tag\n    this.data = data\n    this.children = children\n    this.text = text\n    this.elm = elm\n    this.ns = undefined\n    this.context = context\n    this.fnContext = undefined\n    this.fnOptions = undefined\n    this.fnScopeId = undefined\n    this.key = data && data.key\n    this.componentOptions = componentOptions\n    this.componentInstance = undefined\n    this.parent = undefined\n    this.raw = false\n    this.isStatic = false\n    this.isRootInsert = true\n    this.isComment = false\n    this.isCloned = false\n    this.isOnce = false\n    this.asyncFactory = asyncFactory\n    this.asyncMeta = undefined\n    this.isAsyncPlaceholder = false\n  }\n\n  // DEPRECATED: alias for componentInstance for backwards compat.\n  /* istanbul ignore next */\n  get child (): Component | void {\n    return this.componentInstance\n  }\n}\n```\n\nvnode可以理解为**节点描述对象**，它描述了应该怎样去创建一个真实的DOM节点，例如：tag表示节点的名称，text表示文本节点的文本，children表示子节点~\n\nvnode代表的是一个真实的DOM元素，所有的真实DOM节点都使用vnode创建并插入到页面中。\n\n在vue.js中会对vnode进行缓存，当有新的vnode时会与旧的vnode进行对比，只更新发生变化的节点，以节省性能，这时vnode最重要的一个作用\n\n\n\nvnode的类型有以下几种：\n\n* 注释节点\n* 文本节点\n* 元素节点\n* 组件节点\n* 函数式组件\n* 克隆节点\n\n###  注释节点\n\n创建注释节点：\n\n```js\nexport const createEmptyVNode = (text: string = '') => {\n  const node = new VNode()\n  node.text = text\n  node.isComment = true\n  return node\n}\n```\n\n注释节点只有两个有效属性： `text`、`isComment`对应vnode应该是这样的：\n\n``` js\n{\n    text: '注释节点',\n    isComment: 'true'\n}\n// <!--注释节点-->\n```\n\n### 文本节点\n\n创建过程：\n\n``` js\nexport function createTextVNode (val: string | number) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n```\n\n文本节点被创建时只有一个text属性，因此对应vnode应该是：\n\n``` js\n{\n    text: 'Hello World'\n}\n```\n\n###  克隆节点\n\n克隆节点是将现有节点的属性复制到新的节点中，让新创建的节点属性与克隆节点保持一致实现克隆效果。\n\n克隆节点的作用是优化静态节点和插槽节点（slot node）\n\n以静态节点为例，当组件内的某个状态发生改变时，当前组件会通过虚拟DOM重新渲染视图，静态节点因为他的内容不会改变，所以除了首次渲染外其他时候都不需要重新生成新的vnode，此时使用创建**克隆节点**的方法将vnode进行克隆，使用克隆节点进行渲染，这样就不需要重新执行渲染函数生成新的静态节点，也就提升了一定程度的性能\n\n克隆节点的创建过程：\n\n``` js\nexport function cloneVNode (vnode: VNode): VNode {\n  const cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    // #7975\n    // clone children array to avoid mutating original in case of cloning\n    // a child.\n    vnode.children && vnode.children.slice(),\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  )\n  cloned.ns = vnode.ns\n  cloned.isStatic = vnode.isStatic\n  cloned.key = vnode.key\n  cloned.isComment = vnode.isComment\n  cloned.fnContext = vnode.fnContext\n  cloned.fnOptions = vnode.fnOptions\n  cloned.fnScopeId = vnode.fnScopeId\n  cloned.asyncMeta = vnode.asyncMeta\n  cloned.isCloned = true\n  return cloned\n}\n```\n\n从代码可以看出，创建克隆节点时只需要将现有节点的全部属性复制到新节点中即可，与源节点的区别是克隆节点的isCloned属性为true\n\n###  元素节点\n\n元素节点存在四个属性：\n\n* tag：如p, ul, li, div等\n* data：节点上的数据如：attrs、class、style等\n* children：当前节点的子节点列表\n* context：当前组件的vue.js实例\n\n``` html\n<p><span>aaa</span><span>bbb</span></p>\n```\n\n这是一个真实的元素节点\n\n对应Vnode应该时这样的：\n\n``` js\n{\n    children: [VNode, VNode],\n    contextL: {...},\n    data: {...},\n    tag: \"p\",\n    ...\n}\n```\n\n###  组件节点\n\n组件节点与元素节点类似，它有两个独特的属性\n\n* **componentOptions：** 组件节点的选项参数，其中包含propData、tag、children等\n* **componentInstance：**组件的实例，也是Vue的实例，在Vue.js中每一个组件都是一个Vue实例\n\n\n\n###  函数式组件\n\n函数式组件与组件节点类似，它独有的属性是：`functionalContext`和`functionalOptions`\n\n\n\n##  patch\n\n虚拟DOM最核心的部分就是**patch**，它可以将vnode渲染成真实的DOM\n\npatch也被称为**pathching**算法，在对真实DOM进行渲染时，它会对比新旧vnode有什么不同，然后根据对比结果找出需要更新的节点\n\npatch不是暴力替换节点，而是在现在DOM上进行修改来达到渲染视图的目的，渲染的过程基本如下：\n\n* 创建新增的节点\n* 删除已经废弃的节点\n* 修改需要更新的节点\n\n###  新增节点\n\n首次渲染时（此时页面内部没有节点，不存在oldVnode），我们面临的是不存在oldVnode的情况，这是我们只需要使用vnode直接创建元素并渲染视图就可以了\n\n而当vnode被创建后，oldVnode存在且与vnode完全不一样的时候，会以vnode为标准来进行视图渲染，此时vnode是一个全新的节点，而oldVnode是一个被废弃的节点，\n\n这时我们需要的就是使用vnode创建一个新的DOM节点，用这个节点去替换oldVnode所对应的节点\n\n\n\n###  创建节点\n\n事实上只有三种类型的节点会被创建并插入到DOM中：元素机欸但、注释节点和文本节点\n\n要判断vnode是否是元素节点，只需要判断它是否拥有tag属性，如果一个vnode据哟itag属性，那么旧认为他是元素节点，这时就会调用当前环境下的`createElement`（浏览器中时调用`document.createElement`）来创建真实的元素节点，元素节点被创建后，需要将它渲染到视图中\n\n这个渲染过程也是比较简单的，只需要调用当前环境下的`appendChild`（浏览器中调用`parentNode.appendChild`）就可以将一个元素节点插入到指定的父节点中，如果这个父节点已经被渲染到视图中，那么元素节点插入后会被自动渲染\n\n其实创建节点的过程中还需要创建他的子节点，子节点的创建过程是一个递归过程，vnode中的children属性保存了当前节点的所有子虚拟节点（child virtual node）对children递归创建，对每一个子节点都执行一遍创建节点的过程，这样就会渲染出一个完整的DOM结构\n\n\n\n除去元素节点外，还有注释节点和文本节点需要创建，注释节点的特性就是属性isComment为true，所以通过对这个属性的判断旧可以判断vnode是不是一个注释节点，如果是一个注释节点，就会调用当前环境下的`createComment`（浏览器下`document.createComment`）来创建真实的注释节点并插入到指定父节点中\n\n如果是文本节点，就会调用当前环境的`createTextNode`方法（浏览器下`document.createTextNode`）来创建真实的文本节点并将其加入到指定的父节点中\n\n\n\n###  删除节点\n\n在新增节点中提到过，当有一个vnode对oldVnode进行替换时根据vnode创建的新节点插入到就节点的旁边，然后oldValue对应的旧节点会被删除，这样就完成了替换的过程\n\n源码中是这么写的：\n\n``` js\n function removeVnodes (vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      const ch = vnodes[startIdx]\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch)\n          invokeDestroyHook(ch)\n        } else { // Text node\n          removeNode(ch.elm)\n        }\n      }\n    }\n  }\n```\n\n就是删除vnodes数组中从startIdx指定位置到endIdx指定位置的内容，removeNode用于删除视图中的单个节点，而removeVnodes用于删除一组指定的节点\n\n``` js\nconst nodeOps = {\n    removeChild(node, child) {\n        node.removeChild(child)\n    }\n}  \n\nfunction removeNode (el) {\n    const parent = nodeOps.parentNode(el)\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el)\n    }\n  }\n```\n\nnodeOps的封装是为了更好地进行跨平台渲染，这里的逻辑就是将当前的元素从它的父节点中删除，noideOps是对节点操作的封装\n\n\n\n###  更新节点\n\n下图是一个替换文字的简单例子，视图中的文本节点包含的文字是“我是文字”，而当状态发生变化时，将文本改成了“我是文字2“，这时根据改变后的状态生成了新的vnode，然后将vnode与oldVnode进行对比，发现他们是同一个节点，深层次对比后，发现文字发生了变化，最后将真实DOM中的文本改成了vnode中的文字”我是文字2“\n\n![ttsKiV.jpg](https://s1.ax1x.com/2020/06/02/ttsKiV.jpg)\n\npatch的工作流程大致如下图所示：\n\n![ttcbTA.jpg](https://s1.ax1x.com/2020/06/02/ttcbTA.jpg)\n\n静态节点指的是那些一定那渲染到界面上，无论状态如何改变，都不会发生变化的节点\n\n``` html\n<p>静态节点</p>\n```\n\n这就是一个静态节点，即无论状态怎样变化，这个节点都不会受到影响而进行重新渲染，它永远都不需要重新渲染\n\n\n\n当新旧两个虚拟节点不是静态节点并且拥有不同属性时可以根据vnode是否拥有text属性来进行不同的更新\n\n####  有text属性\n\n如果新的vnode拥有text属性那么不论之前的就节点的子节点是什么，都可以直接调用`setTextContent`方法（浏览器下`node.setTextContext`）来将视图中DOM节点的内容改为虚拟节点\n\n当然如果之前的oldVnode中也拥有text属性那么就不需要使用`setTextContent`来设置相同的文本，只需要直接把真实DOM节点的内容改成新vnode的文本即可\n\n\n\n####  没有text属性\n\n如果vnode中不存在text属性，那么他就是一个元素节点，元素节点的更新通常会根据它是否有子节点而有所区别\n\n####  有children属性\n\n当vnode有children属性时，如果旧节点有children属性，那么旧需要对新旧节点的children进行详细的对比你并更新\n\n如果旧虚拟节点没有children属性，那么说明旧的虚拟节点是一个空标签，要么就是一个文本节点，如果是文本节点那么就需要将其清空，然后根据新的vnode的children挨个创建真实的DOM元素节点并插入到视图的DOM中\n\n####  无children属性\n\n当vnode既没有text属性也没有children属性时，说明这个节点是一个空节点，那么这时oldVnode中如果存在子节点就将子节点删除，如果存在文本就将文本删除，直到剩余空标签为止\n\n\n\n###  更新子节点\n\n更新子节点大致分为4种操作：更新节点、新增节点、删除节点、移动节点\n\n对比两个子节点列表（children）首先就是循环，循环newChildren（新子节点列表），每循环到一个新的子节点，就去oldChildren（旧子节点列表）中寻找与之相对应的节点，如果找不到就说明这个子节点是因为状态改变而新增的节点，因此需要创建节点并插入视图，如果找到了相应的节点，那么就执行更新操作\n\n####  更新策略\n\n更新策略主要包括：新增节点、更新节点、移动节点、删除节点\n\n#####  更新子节点\n\n如果我们在newChildren中发现了一个节点同时存在于oldChildren中时我们就需要对这个节点进行更新操作\n\n如果两个节点同处于两个子节点列表的相同位置，那么这时我们只需要对两个节点进行正常的节点更新操作\n\n但是如果两个节点处理两个列表的不同位置，那么此时就要进行我们的下一步错做**移动节点**\n\n\n\n#####  移动子节点\n\n如上文所述，当与newChildren中的新节点对应节点处于oldChildren的不同位置时，我们就需要进行移动子节点\n\n移动的基本策略就是将真实DOM中的对应节点移动到newChildren中该节点对应的位置\n\n通过`Node.insertBefore()`方法，我们可以成功地将一个已有节点移动到一个指定的位置\n\n而这个指定位置其实就是newChildren中所有未处理节点的第一个位置\n\n\n\n#####  新增子节点\n\n当我们在旧子节点列表中没有找到当前子节点列表中的节点时，我们需要创建一个新的节点并且插入到oldChildren中所有未处理节点的前面。节点成功插入DOM后这一次循环也就结束了\n\n可定有人不理解为什么插入到所有未处理节点的前面而不是插入到已处理节点的后面，可以举例说明一下：\n\n假如说有以下DOM、newChildren、oldChildren：\n\n> DOM   ======> [【已处理】，【已处理】，【未处理】，【未处理】]\n\n> newChildren => [【已处理】，【已处理】，<font color='red'>【新节点】</font>，【未处理】]\n\n> oldChildren   => [【已处理】，【已处理】，【未处理】，【未处理】]\n\n此时newChildren中的【新节点】在oldChildren中找不到对应的节点，因此会创建新的节点，并且插入到DOM节点的第三个位置，此时：\n\n> DOM   ======> [【已处理】，【已处理】，<font color='red'>【新节点】</font>，【未处理】，【未处理】]\n\n这样看感觉怎么说都是正确的，因为确实新节点添加到了已处理节点的后面，也可以说时添加到了未处理节点的前面\n\n但是请看下一个例子：\n\n> DOM   ======> [【已处理】，【已处理】，<font color=\"green\">【已处理】</font>，【未处理】，【未处理】]\n\n> newChildren => [【已处理】，【已处理】，<font color=\"green\">【已处理】</font>，<font color='red'>【新节点】</font>]\n\n> oldChildren   => [【已处理】，【已处理】，【未处理】，【未处理】]\n\n此时按照添加到已处理节点后面的逻辑思想，下一步操作应该时这样的：\n\n> DOM   ======> [【已处理】，【已处理】，<font color=\"green\">【已处理】</font>，<font color='red'>【新节点】</font>，【未处理】，【未处理】]\n\n但是事与愿违，其实真实按照这种逻辑的操作是这样的：\n\n> DOM   ======> [【已处理】，【已处理】，<font color='red'>【新节点】</font>，<font color=\"green\">【已处理】</font>，【未处理】，【未处理】]\n\n我们会发现在我们的逻辑中本应该被添加到第四位的<font color='red'>【新节点】</font>被添加到了第三个位置，为什么呢?\n\n**答：** 原因是我们之前说过更新节点过程中对应newChildren循环搜索是否有同一节点的是**oldChildren**o但是在旧子节点列表中只有两个已处理节点，因此如果添加到已处理节点后面的话，就是应该添加到第三位，所以在DOM中也会添加到<font color=\"green\">【已处理】</font>的前面\n\n\n\n基于上述情况，我们可以发现真正的创建操作是将新的节点添加到所有未处理节点的前面\n\n这样我们也发现我们仅仅添加了节点，但是并没有对节点进行删除操作，因此我们下面就来说说子节点的删除操作\n\n\n\n#####  删除子节点\n\n删除子节点，本质上就是删除那些oldChildren中存在但是newChildren中不存在的节点\n\n举个例子：\n\n> DOM   ======> [【已处理】，【已处理】，<font color=\"green\">【已处理】</font>，【未处理】，【未处理】]\n\n> newChildren => [【已处理】，【已处理】，<font color=\"green\">【已处理】</font>，<font color='red'>【新节点】</font>]\n\n> oldChildren   => [【已处理】，【已处理】，【未处理】，【未处理】]\n\noldChildren中两个【未处理】节点其实都是应该删除的节点，也就是废弃的节点，\n\n也就是说当newChildren循环一遍以后，如果oldChildren中还有没有处理的节点，那么这些节点就时被废弃且应该删除掉的节点\n\n\n\n#####  更新优化策略\n\n上述四种操作都是需要的，但不一定都是必须的，通常情况下，并不是所有的子节点的位置都会发生移动，一个节点列表中总会有那么几个节点位置是不变的，那么我们也不必总是循环查找。\n\n那我们是不是可以更快、更加精准的直到要对比的oldChildren中对应节点的位置呢？或者说我们能不能预测以下这个节点可能处于什么位置，这就是策略更新。\n\n假设有这样的场景：\n\n> 我们仅仅更新了列表中某个数据的内容，那么这时我们newChildren中节点对应的位置是不是应该与oldChildren中对应节点所在的位置相同呢？\n\n是的，我们可以尝试这样的操作：当我们循环到newChildren中的一个节点是，我们先判断oldChildren中对应位置的节点是否与这个节点向对应，如果对应那么就可以直接进行节点更新，如果不对应，我们再进行循环查找，\n\n这样很大程度上避免了每次都循环oldChildren来查找节点，这样大大提升了执行的速度\n\n而查找方式可以分为4种：\n\n* 新前与旧前\n* 新前与旧后\n* 新后与旧后\n* 新后与旧前\n\n> 新前：newChildren中所有未处理节点的第一个节点，**newStartVnode**\n>\n> 新后：newChildren中所有未处理节点的最后一个节点，**newEndVnode**\n>\n> 旧前：oldChioldren中所有未处理节点的第一个节点，**oldStartVnode**\n>\n> 旧后：oldChildren中所有未处理节点的最后一个节点，**oldEndVnode**\n\n***\n\n######  新前与旧前\n\n意思就是我们尝试对比“新前”与“旧前”是否是同一个节点，如果是那就不需要执行移动操作，只需要对这个节点进行更新即可\n\n\n\n######  新后与旧后\n\n与上一个相同，只需要使用“新后”与“旧后”对比，如果是那就不需要执行移动操作，只需要对这个节点进行更新即可\n\n\n\n######  新后与旧前\n\n当我开始理解这个概念的时候直接弄错了“新后”与旧前的概念，<font color=\"red\">建议看到这里重新看一下上面关于这四个概念的解释</font>\n\n当我们对比“新后”与“旧前”，发现他们是对应节点后，我们应该在更新DOM的同时将节点移动到oldChildren所有未处理节点的最后面\n\n那么问题来了：为什么要移动到oldChildren所有未处理节点的最后面\n\n**答：**我们都知道更新节点时以新虚拟节点未基准的，而我们知道“新后”是newChildren所有未处理节点的最后一个，因此在对应移动时我们需要将真实DOM中的这个节点移动到最后\n\n但是“移动到真实节点的最后面”和“移动到oldChildren所有未处理节点的最后面“有区别吗？\n\n答案是：有的！\n\n假设newChildren、oldChildren和DOM中的首尾节点都已经处理完毕了，那么此时我们对比“新后”与“旧前”，发现他们一致，这时我们如果将DOM中的节点移动到DOM节点的最后，就会发现位置不匹配，DOM中这个节点在之前尾部【已处理】节点的后面，而newChildren中这个节点在尾部【已处理】节点的前面，位置不匹配，因此才需要移动到oldChildren中所有未处理节点的最后面\n\n\n\n######  新前与旧后\n\n”新前“与”旧后“的处理原则与上面的”新后”与“旧前“的处理原则时一致的，这里就不细说了，举一反三！ ^-^\n\n***\n\n当以上四种方式都没有找到相同节点时，我们再使用循环的方式去搜索节点，看能否找到，这样就减少了很多的循环操作，有效提高了性能\n\n\n\n####  怎样判断未处理节点\n\n如果直接让我们来想这个功能的话，其实正常情况下我们直接使用一次循环，从头到尾肯定能保证只有未处理的节点能够进入循环，这样肯定没有错，但是我们有**优化策略**在先，当我们使用优化策略后，已经处理的节点可能并不在前面甚至可能在未处理节点后面，这时该怎么判断呢？\n\n我们发现上面几种策略都是在列表前后进行操作的，因此我们只要从两边向中间进行循环就可以的，这也就是Vue中采取的策略。\n\n**循环策略：**\n\n首先定义4个变量：oldStratIdx、oldEndIdx、newStartIdx和newEndIdx\n\n分别记录了oldChildren和newChildren循环开始的位置和循环结束的位置\n\n当开始位置的节点被处理后，就将开始下标后移一位，结束位置的节点被处理后，将结束位置下标前移一位，这样就能保证从两边向中间循环\n\n结束循环的判断条件是这样的：当开始位置大于等于结束位置时就说明所有节点已经遍历过了\n\n``` js\n while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n     //内部循环\n }\n```\n\n我们可以发现当oldChildren或者newChildren中有一个循环完毕就会退出循环，也就是时可能存在无法覆盖其全部节点对的情况，为什么呢？没有覆盖的节点怎么处理呢？\n\n细细思考一下就会发现，循环是能够找出差异的，这不也正是我们循环的目的吗？\n\n当oldChildren先循环结束时，newChildren中多出来的节点就都是新增的节点，也就是需要新创建的节点\n\n当newChildren先循环结束时，oldChildren中剩余的节点就都是需要删除的，这时就不需要进行循环比对，直接删除就可以了.\n\n#####  key\n\n当然我们都知道使用Vue渲染列表时，推荐使用属性**key**，这时因为使用key与index索引建立关系后，相当于拥有了唯一ID，这时查找节点不需要进入循环，只需要直接更新对应位置的节点就可以了\n\n\n\n##  总结\n\n以上就是Vue的虚拟DOM的知识，在虚拟DOM中，最重要的技术就是：**patch**，虚拟DOM的应用有效提高了性能，减少了可见的 DOM操作，对开发有很大的帮助\n\n\n\n##  文后自言\n\n这是自更新博客后第一次写这么长对的文章（貌似除了论文还没写过这么多字），受益匪浅，推荐几个受益良多的书籍与博客吧\n\n* 刘博文的《深入浅出Vue.js》\n* [神三元](https://juejin.im/user/5c45ddf06fb9a04a006f5491/posts)的 浏览器，原生JS，HTTP系列文章\n* **axuebin**的 [前端知识脑图](https://juejin.im/post/5e8b163ff265da47ee3f54a6#heading-12)",
    __v: NumberInt("0")
} ]);

// ----------------------------
// Collection structure for test
// ----------------------------
db.getCollection("test").drop();
db.createCollection("test");

// ----------------------------
// Documents of test
// ----------------------------
db.getCollection("test").insert([ {
    _id: ObjectId("5ee9912a0a6ad85e273e888d"),
    name: "ryz"
} ]);

// ----------------------------
// Collection structure for users
// ----------------------------
db.getCollection("users").drop();
db.createCollection("users");

// ----------------------------
// Documents of users
// ----------------------------
db.getCollection("users").insert([ {
    _id: ObjectId("5eef25a02cc62301246012b8"),
    username: "星雪工作室",
    password: "d3149fef322fa523c947b09f5d7ec808",
    phone: "15848156087",
    account: "15848156087",
    type: "team",
    "article_count": NumberInt("0"),
    description: "追出梦想，杨帆起航",
    __v: NumberInt("0")
} ]);
db.getCollection("users").insert([ {
    _id: ObjectId("5eef284a68e4b7415c23e100"),
    username: "幻尘",
    password: "d3149fef322fa523c947b09f5d7ec808",
    phone: "17648292236",
    account: "17648292236",
    team: "星雪工作室",
    type: "personal",
    "article_count": NumberInt("0"),
    description: "追出梦想，杨帆起航",
    __v: NumberInt("0")
} ]);
